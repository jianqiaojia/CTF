# VM 字节码程序反汇编

## 原始字节码
```
地址      字节码
0x00:     81 34 00 00 00 00 00 00 00 00
0x0A:     31 00 00 00 00
0x0F:     32 01 00 00 00
0x14:     33 C2 00 00 00
0x19:     50
0x1A:     07 C2 00 00 00
0x1F:     82
0x20:     83
0x21:     08 00 00 00 00 00 00 00 00
0x2A:     34 00 00 00 00 00 00 00 00
0x33:     05 01 00 00 00
0x38:     40 01 C0 00 00 00
0x3E:     51
```

## 逐条指令分析

### 指令 1 (PC=0x00): `0x81`
**操作码**: 0x81
```c
case 0x81:
    v9 = dword_1800059AC;  // reg0 = *[0x1800059AC]
    goto LABEL_133;
```
- **功能**: 从固定地址 `0x1800059AC` 加载值到 reg0
- **reg0**: 初始位置值（应该是起点标记）

---

### 指令 2 (PC=0x01): `0x34 00 00 00 00 00 00 00 00`
**操作码**: 0x34 (存储 reg0 到内存)
**参数**: 64位地址 = 0x0000000000000000
```c
case 0x34:
    v64 = v5 + 4;  // v64 = PC + 4
    v65 = 读取4字节立即数;
    // ... 读取完整的8字节地址
    *[地址] = v9;  // *[0] = reg0
```
- **功能**: 将 reg0 的值存储到地址 0 处
- **作用**: 保存当前位置

---

### 指令 3 (PC=0x0A): `0x31 00 00 00 00`
**操作码**: 0x31 (加载立即数到 reg1)
**参数**: 24位立即数 = 0x000000
```c
case 0x31:
    v58 = v5 + 1;
    v59 = (byte[v5+2] | (byte[v5+3] << 8)) << 8;
    v5 += 4;
    v8 = byte[v11] | ((byte[v58] | v59) << 8);  // reg1 = 0
    dword_180005674 = v8;
```
- **功能**: reg1 = 0
- **用途**: 输入数组索引初始化

---

### 指令 4 (PC=0x0F): `0x32 01 00 00 00`
**操作码**: 0x32 (加载立即数到 reg2)
**参数**: 24位立即数 = 0x000001
```c
case 0x32:
    v7 = 立即数;  // reg2 = 1
    dword_180005678 = v7;
```
- **功能**: reg2 = 1
- **用途**: Y坐标初始化为1

---

### 指令 5 (PC=0x14): `0x33 C2 00 00 00`
**操作码**: 0x33 (加载立即数到 reg3)
**参数**: 24位立即数 = 0x0000C2 (194)
```c
case 0x33:
    v6 = 立即数;  // reg3 = 194
    dword_18000567C = v6;
```
- **功能**: reg3 = 194 (0xC2)
- **用途**: 数组每行的宽度

---

### 指令 6 (PC=0x19): `0x50`
**操作码**: 0x50 (标记循环起点)
```c
case 0x50:
    dword_18000568C = v5;  // 保存当前PC
```
- **功能**: 保存循环起点位置 (PC = 0x1A)
- **用途**: 用于后续的条件跳转

---

### 指令 7 (PC=0x1A): `0x07 C2 00 00 00`
**操作码**: 0x07 (reg3 += 立即数)
**参数**: 24位立即数 = 0x0000C2 (194)
```c
case 7:
    v6 += 立即数;  // reg3 += 194
    dword_18000567C = v6;
```
- **功能**: reg3 += 194
- **用途**: 移动到数组的下一行（每次循环都会执行，但实际上这个指令在这里有点奇怪）

---

### 指令 8 (PC=0x1F): `0x82`
**操作码**: 0x82 (从输入数组加载)
```c
case 0x82:
    v9 = v104[v8];  // reg0 = input[reg1]
    goto LABEL_133;
```
- **功能**: reg0 = input[reg1]
- **用途**: 读取当前索引的输入字符 ('0' 或 '1')

---

### 指令 9 (PC=0x20): `0x83`
**操作码**: 0x83 (根据输入移动并加载)
```c
case 0x83:
    v79 = v9 - 48;  // 将 '0'/'1' 转换为 0/1
    if (v79 == 0) {
        // 输入是 '0'：保持当前行
        v9 = dword_1800056A0[v6 + v7];  // reg0 = array[reg3 + reg2]
    } else if (v79 == 1) {
        // 输入是 '1'：移动到下一行
        v7++;  // reg2++
        dword_180005678 = v7;
        v9 = dword_1800056A0[v6 + v7];  // reg0 = array[reg3 + reg2]
    } else {
        puts("ERROR!");
        return -1;
    }
    goto LABEL_133;
```
- **功能**: 
  - 如果输入是 '0'：从 array[reg3 + reg2] 加载值
  - 如果输入是 '1'：reg2++，然后从 array[reg3 + reg2] 加载值
- **用途**: 这是核心的"移动"逻辑

---

### 指令 10 (PC=0x21): `0x08 00 00 00 00 00 00 00 00`
**操作码**: 0x08 (从内存加载并累加到 reg0)
**参数**: 64位地址 = 0x0000000000000000
```c
case 0x08:
    v9 += *[地址];  // reg0 += *[0]
    goto LABEL_133;
```
- **功能**: reg0 += *[地址0]
- **用途**: 累加之前保存的位置值

---

### 指令 11 (PC=0x2A): `0x34 00 00 00 00 00 00 00 00`
**操作码**: 0x34 (存储 reg0 到内存)
**参数**: 64位地址 = 0x0000000000000000
```c
case 0x34:
    *[地址] = v9;  // *[0] = reg0
```
- **功能**: 将 reg0 存回地址 0
- **用途**: 更新当前累加的位置值

---

### 指令 12 (PC=0x33): `0x05 01 00 00 00`
**操作码**: 0x05 (reg1 += 立即数)
**参数**: 24位立即数 = 0x000001 (1)
```c
case 5:
    v8 += 立即数;  // reg1 += 1
    dword_180005674 = v8;
```
- **功能**: reg1 += 1
- **用途**: 移动到下一个输入字符

---

### 指令 13 (PC=0x38): `0x40 01 C0 00 00 00`
**操作码**: 0x40 (比较指令)
**参数1**: 0x01 (比较 reg1)
**参数2**: 24位立即数 = 0x0000C0 (192)
```c
case 0x40:
    v77 = 立即数;  // v77 = 192
    switch (参数1) {  // 参数1 = 1，所以比较 reg1
        case 1:
            if (v8 - v77 <= 0)  // if (reg1 <= 192)
                dword_180005680 = (v8 == v77) + 1;  // 如果相等则=2，否则=1
            else
                dword_180005680 = 0;  // reg1 > 192
            break;
    }
```
- **功能**: 比较 reg1 和 192
  - 如果 reg1 < 192: dword_180005680 = 1
  - 如果 reg1 == 192: dword_180005680 = 2
  - 如果 reg1 > 192: dword_180005680 = 0
- **用途**: 检查是否已处理完所有192个输入

---

### 指令 14 (PC=0x3E): `0x51`
**操作码**: 0x51 (条件跳转)
```c
case 0x51:
    if (dword_180005680 == 1) {
        v5 = dword_18000568C;  // PC = 保存的循环起点
        dword_180005684 = dword_18000568C;
    }
```
- **功能**: 如果 dword_180005680 == 1，跳转到标记的循环起点 (PC=0x1A)
- **用途**: 当 reg1 < 192 时，继续循环

---

## 程序流程总结

```
1. reg0 = 起始位置值 (从 0x1800059AC)
2. *[0] = reg0 (保存初始位置)
3. reg1 = 0 (输入索引)
4. reg2 = 1 (Y坐标)
5. reg3 = 194 (行宽)

6. [循环起点标记]
7. reg3 += 194  (移动到下一个"段")
8. reg0 = input[reg1]  (读取输入字符)
9. 如果 input == '0': reg0 = array[reg3 + reg2]
   如果 input == '1': reg2++; reg0 = array[reg3 + reg2]
10. reg0 += *[0]  (累加之前的位置)
11. *[0] = reg0  (保存新位置)
12. reg1++  (下一个输入)
13. 比较 reg1 和 192
14. 如果 reg1 < 192，跳回步骤 6

循环结束后，*[0] 包含最终的累加值
```

## 关键观察

这个VM程序并不是真正的迷宫寻路！它实际上在做：
1. 每次读取一个输入字符
2. 根据输入 '0' 或 '1' 选择数组中的不同值
3. 累加这些值
4. 循环192次

但问题是：`dword_1800056A0` 数组全是 0xFF！
这意味着无论输入什么，每次累加的都是 0xFF，最终结果只取决于执行了多少次累加。

让我验证一下是否还有其他数据...