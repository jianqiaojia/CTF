# VM 指令集详解

## 寄存器
- `reg0` (v9): 累加器/通用寄存器
- `reg1` (v8): 通用寄存器（用作输入数组索引）
- `reg2` (v7): 通用寄存器（用作Y坐标）
- `reg3` (v6): 通用寄存器（用作数组偏移）
- `PC` (v5/v11): 程序计数器
- `dword_180005680`: 比较结果标志
- `dword_18000568C`: 保存的跳转目标

## 指令格式

### 0x00-0x03: ADD_IMM64 (8字节立即数加法)
**格式**: `opcode imm32_low imm32_high`
**参数**: 8字节（2个32位立即数）
**操作**:
- `case 0`: `reg0 = imm32_low + imm32_high`
- `case 1`: `reg1 = imm32_low + imm32_high`
- `case 2`: `reg2 = imm32_low + imm32_high`
- `case 3`: `reg3 = imm32_low + imm32_high`

**示例**:
```
00 12 34 56 78 9A BC DE F0  ; reg0 = 0x78563412 + 0xF0DEBC9A
```

---

### 0x04-0x07: ADD_IMM24 (3字节立即数加法)
**格式**: `opcode imm24`
**参数**: 3字节立即数
**操作**:
- `case 4`: `reg0 += imm24`
- `case 5`: `reg1 += imm24`
- `case 6`: `reg2 += imm24`
- `case 7`: `reg3 += imm24`

**示例**:
```
07 C2 00 00 00  ; reg3 += 0x0000C2 (194)
```

---

### 0x08-0x0B: ADD_MEM (从内存加载并加法)
**格式**: `opcode addr64`
**参数**: 8字节地址
**操作**:
- `case 8`: `reg0 += *[addr64]`
- `case 9`: `reg1 += *[addr64]`
- `case 10` (0xA): `reg2 += *[addr64]`
- `case 11` (0xB): `reg3 += *[addr64]`

**示例**:
```
08 00 00 00 00 00 00 00 00  ; reg0 += *[0x0000000000000000]
```

---

### 0x0C-0x0F: REG_OP (寄存器间运算)
**格式**: `opcode src_reg dst_reg`
**参数**: 2字节（源寄存器，目标寄存器）
**操作**: 根据 dst_reg 选择操作
- `case 0x0C`: 操作 reg0
- `case 0x0D`: 操作 reg1
- `case 0x0E`: 操作 reg2
- `case 0x0F`: 操作 reg3

**dst_reg 值**:
- `0`: 加到 reg0
- `1`: 加到 reg1
- `2`: 加到 reg2
- `3`: 加到 reg3
- 其他: 减1

**示例**:
```
0C 01 00  ; dst=reg0, src=reg1 -> reg0 += reg1
```

---

### 0x30-0x33: MOV_IMM24 (加载立即数)
**格式**: `opcode imm24`
**参数**: 3字节立即数
**操作**:
- `case 0x30`: `reg0 = imm24`
- `case 0x31`: `reg1 = imm24`
- `case 0x32`: `reg2 = imm24`
- `case 0x33`: `reg3 = imm24`

**示例**:
```
31 00 00 00 00  ; reg1 = 0
32 01 00 00 00  ; reg2 = 1
33 C2 00 00 00  ; reg3 = 194
```

---

### 0x34-0x37: STORE (存储寄存器到内存)
**格式**: `opcode addr64`
**参数**: 8字节地址
**操作**:
- `case 0x34`: `*[addr64] = reg0`
- `case 0x35`: `*[addr64] = reg1`
- `case 0x36`: `*[addr64] = reg2`
- `case 0x37`: `*[addr64] = reg3`

**示例**:
```
34 00 00 00 00 00 00 00 00  ; *[0] = reg0
```

---

### 0x40: CMP (比较指令)
**格式**: `opcode reg_id imm24`
**参数**: 1字节寄存器ID + 3字节立即数
**操作**: 比较指定寄存器和立即数
- `reg_id=0`: 比较 reg0
- `reg_id=1`: 比较 reg1
- `reg_id=2`: 比较 reg2
- `reg_id=3`: 比较 reg3

**结果** (存入 `dword_180005680`):
- `0`: reg > imm
- `1`: reg < imm
- `2`: reg == imm

**示例**:
```
40 01 C0 00 00 00  ; 比较 reg1 和 192
```

---

### 0x50: MARK (标记位置)
**格式**: `opcode`
**参数**: 无
**操作**: `dword_18000568C = PC` (保存当前PC)

**示例**:
```
50  ; 标记这个位置用于后续跳转
```

---

### 0x51: JMP_IF (条件跳转)
**格式**: `opcode`
**参数**: 无
**操作**: 如果 `dword_180005680 == 1`，则 `PC = dword_18000568C`

**示例**:
```
51  ; 如果比较结果是"小于"，跳转到标记位置
```

---

### 0x60: DEBUG (调试输出)
**格式**: `opcode`
**参数**: 无
**操作**: 调用 `sub_1800010F0("TEST:%d\n")` 两次

**示例**:
```
60  ; 打印调试信息
```

---

### 0x81: LOAD_CONST (从固定地址加载)
**格式**: `opcode`
**参数**: 无
**操作**: `reg0 = dword_1800059AC`

**示例**:
```
81  ; reg0 = 初始值
```

---

### 0x82: LOAD_INPUT (从输入数组加载)
**格式**: `opcode`
**参数**: 无
**操作**: `reg0 = input_array[reg1]`

**示例**:
```
82  ; reg0 = input[reg1]  (读取用户输入的字符)
```

---

### 0x83: MOVE_AND_LOAD (根据输入移动并加载)
**格式**: `opcode`
**参数**: 无
**操作**:
```c
v79 = reg0 - 48;  // 将 ASCII '0'/'1' 转为数字 0/1
if (v79 == 0) {
    // 输入是 '0'：保持当前位置
    reg0 = array[reg3 + reg2];
} else if (v79 == 1) {
    // 输入是 '1'：向下移动
    reg2++;
    reg0 = array[reg3 + reg2];
} else {
    // 无效输入
    puts("ERROR!");
    return -1;
}
```

**示例**:
```
83  ; 根据输入 '0'/'1' 移动并从数组加载
```

---

## 程序字节码示例

```
地址    字节码                         汇编伪代码
00:     81                            reg0 = CONST_START
01:     34 00 00 00 00 00 00 00 00    *[0] = reg0
0A:     31 00 00 00 00                reg1 = 0
0F:     32 01 00 00 00                reg2 = 1
14:     33 C2 00 00 00                reg3 = 194
19:     50                            MARK_LOOP:
1A:     07 C2 00 00 00                reg3 += 194
1F:     82                            reg0 = input[reg1]
20:     83                            MOVE_AND_LOAD
21:     08 00 00 00 00 00 00 00 00    reg0 += *[0]
2A:     34 00 00 00 00 00 00 00 00    *[0] = reg0
33:     05 01 00 00 00                reg1 += 1
38:     40 01 C0 00 00 00             CMP reg1, 192
3E:     51                            JMP_IF_LESS MARK_LOOP
```

## 程序逻辑

这个VM程序实现了一个简单的循环：
1. 初始化：设置起始位置，初始化寄存器
2. 循环192次（对应192位输入）：
   - 读取一个输入字符 ('0' 或 '1')
   - 根据输入决定是否移动（'1'则Y坐标+1）
   - 从数组中加载值
   - 累加到位置变量
3. 循环结束

但关键是：数组 `dword_1800056A0` 中的值全是 0xFF！
这意味着VM的执行实际上不影响最终的flag生成。
真正的flag生成在VM执行后的代码中，将192位输入转换为24字节，然后XOR硬编码的值。