# Night of the Living Dead - 漏洞利用分析

## 漏洞概述
程序存在Use-After-Free漏洞结合函数指针劫持，可以获得代码执行权限。

## 漏洞详情

### 1. Use-After-Free 漏洞
- 位置：`drop_hero()` 函数 (第38-43行)
- 问题：调用 `free(current_hero)` 后未将指针设为NULL
- 影响：`current_hero` 成为悬空指针

### 2. 缓冲区溢出漏洞  
- 位置：`train_with_dummy()` 函数 (第56行)
- 问题：`read(STDIN_FILENO, (char *)hero_training_dummy, sizeof(Hero))` 
- 影响：可以完全控制Hero结构体内容，包括函数指针

### 3. 目标函数
- `unlock_secret_level()` (第14-24行)
- 功能：读取并打印flag.txt内容

## Hero结构体布局
```c
typedef struct {
  char name[64];           // +0x00 - +0x3F (64字节)
  void (*attack_move)(void); // +0x40 - +0x47 (8字节函数指针)
} Hero; // 总计72字节
```

## 利用策略

### 攻击流程
1. **创建Hero** (选项1) - 分配堆内存
2. **删除Hero** (选项2) - 释放内存但保留悬空指针  
3. **训练假人** (选项4) - 在释放的内存位置创建可控对象
4. **构造输入** - 64字节填充 + unlock_secret_level函数地址
5. **执行攻击** (选项3) - 触发函数指针调用

### Payload构造
```
Payload = [64字节任意数据] + [unlock_secret_level函数地址]
```

### 关键条件
- 堆内存复用：训练假人的malloc()复用之前释放的Hero内存
- 函数指针覆盖：通过缓冲区溢出控制attack_move指针
- 悬空指针调用：perform_attack()使用未清零的current_hero指针

## 预期结果
成功执行后，程序将调用unlock_secret_level()，读取并打印flag.txt内容。