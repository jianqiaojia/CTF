#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
验证找到的flag是否正确
"""

import socket
import time

def connect_to_server():
    """连接到远程服务器"""
    host = "strcmp.chall.edgesecurity.team"
    port = 1341
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((host, port))
        return sock
    except Exception as e:
        print(f"[-] 连接失败: {e}")
        return None

def test_flag_with_end_chars(base_flag):
    """测试在flag末尾添加不同字符的响应时间"""
    print(f"测试基础flag: {base_flag}")
    
    # 测试可能的结尾字符
    end_chars = ['}', '', 'M', 'T', 'A', '1', '2', '3', '_', '-']
    
    results = {}
    
    for end_char in end_chars:
        test_flag = base_flag + end_char
        print(f"测试: '{test_flag}'")
        
        times = []
        for _ in range(10):
            sock = connect_to_server()
            if not sock:
                continue
                
            try:
                # 清理初始响应
                sock.settimeout(0.5)
                try:
                    initial = sock.recv(4096)
                except socket.timeout:
                    pass
                
                # 测量时间
                start_time = time.perf_counter()
                sock.send((test_flag + "\n").encode('utf-8'))
                
                try:
                    sock.settimeout(2.0)
                    response = sock.recv(4096)
                except socket.timeout:
                    response = b""
                
                end_time = time.perf_counter()
                times.append(end_time - start_time)
                
            except Exception as e:
                continue
            finally:
                sock.close()
            
            time.sleep(0.05)
        
        if times:
            avg_time = sum(times) / len(times)
            results[end_char] = avg_time
            print(f"  平均时间: {avg_time:.6f}s")
        else:
            print("  测量失败")
        print()
    
    # 显示结果排序
    print("=== 结果排序 (按响应时间) ===")
    sorted_results = sorted(results.items(), key=lambda x: x[1], reverse=True)
    
    for i, (char, time_val) in enumerate(sorted_results, 1):
        char_display = "''" if char == '' else f"'{char}'"
        print(f"{i}. {char_display}: {time_val:.6f}s")
    
    return sorted_results

def interactive_test():
    """交互式测试flag"""
    print("=== 交互式测试 ===")
    
    while True:
        test_input = input("\n请输入要测试的字符串 (或输入 'quit' 退出): ")
        if test_input.lower() == 'quit':
            break
        
        sock = connect_to_server()
        if not sock:
            continue
            
        try:
            # 获取初始响应
            sock.settimeout(1)
            try:
                initial = sock.recv(4096)
                print(f"初始响应: {initial}")
            except socket.timeout:
                pass
            
            # 发送测试字符串
            start_time = time.perf_counter()
            sock.send((test_input + "\n").encode('utf-8'))
            
            try:
                sock.settimeout(3.0)
                response = sock.recv(4096)
                end_time = time.perf_counter()
                
                print(f"响应: {response}")
                print(f"响应时间: {end_time - start_time:.6f}s")
                
            except socket.timeout:
                end_time = time.perf_counter()
                print("响应超时")
                print(f"超时时间: {end_time - start_time:.6f}s")
            
        except Exception as e:
            print(f"错误: {e}")
        finally:
            sock.close()

if __name__ == "__main__":
    print("Flag验证脚本")
    print("=" * 40)
    
    # 从之前的攻击结果得到的flag
    found_flag = "EdgeCTF{fSwP0Ifi6LoY25WLh69P6T3UaBVW3IOU"
    
    # 测试不同的结尾
    print("1. 测试不同的结尾字符...")
    results = test_flag_with_end_chars(found_flag)
    
    if results:
        best_ending = results[0][0]
        complete_flag = found_flag + best_ending
        print(f"\n最可能的完整flag: {complete_flag}")
    
    # 交互式测试
    print("\n2. 开始交互式测试...")
    interactive_test()