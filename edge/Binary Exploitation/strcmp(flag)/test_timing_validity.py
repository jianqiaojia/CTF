#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
验证题目是否适合时间侧信道攻击
测试EdgeCTF{前缀的时间差异
"""

import socket
import time
import statistics

def connect_to_server():
    """连接到远程服务器"""
    host = "strcmp.chall.edgesecurity.team"
    port = 1341
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((host, port))
        return sock
    except Exception as e:
        print(f"[-] 连接失败: {e}")
        return None

def measure_response_time(test_string, num_samples=15):
    """测量响应时间"""
    times = []
    
    for i in range(num_samples):
        sock = connect_to_server()
        if not sock:
            continue
            
        try:
            # 清理初始状态
            sock.settimeout(1)
            try:
                initial = sock.recv(4096)
                print(f"[样本{i+1}] 初始响应: {initial.decode().strip()}")
            except socket.timeout:
                pass
            
            # 测量时间
            start_time = time.perf_counter()
            sock.send((test_string + "\n").encode('utf-8'))
            
            try:
                sock.settimeout(3)
                response = sock.recv(4096)
                print(f"[样本{i+1}] 服务器响应: {response.decode().strip()}")
            except socket.timeout:
                response = b""
                print(f"[样本{i+1}] 响应超时")
            
            end_time = time.perf_counter()
            elapsed = end_time - start_time
            times.append(elapsed)
            print(f"[样本{i+1}] 响应时间: {elapsed:.6f}s")
            
        except Exception as e:
            print(f"[样本{i+1}] 错误: {e}")
        finally:
            sock.close()
        
        time.sleep(0.1)  # 避免过于频繁的连接
    
    if times:
        avg_time = statistics.mean(times)
        std_dev = statistics.stdev(times) if len(times) > 1 else 0
        return avg_time, std_dev, times
    return 0, 0, []

def test_prefix_timing():
    """测试前缀的时间差异"""
    print("=== 测试EdgeCTF{前缀的时间特性 ===")
    
    # 测试不同长度的正确前缀
    prefixes = [
        "",
        "E",
        "Ed", 
        "Edg",
        "Edge",
        "EdgeC",
        "EdgeCT",
        "EdgeCTF",
        "EdgeCTF{",
    ]
    
    # 测试错误的前缀作为对比
    wrong_prefixes = [
        "X",
        "XX",
        "Wrong",
        "WrongCTF{",
        "FLAG{",
        "CTF{",
    ]
    
    print("\n1. 测试正确前缀的时间...")
    correct_results = {}
    
    for prefix in prefixes:
        print(f"\n--- 测试正确前缀: '{prefix}' ---")
        avg_time, std_dev, times = measure_response_time(prefix, num_samples=10)
        correct_results[prefix] = (avg_time, std_dev)
        print(f"平均时间: {avg_time:.6f}s (±{std_dev:.6f}s)")
        if times:
            print(f"最小时间: {min(times):.6f}s, 最大时间: {max(times):.6f}s")
    
    print("\n2. 测试错误前缀的时间...")
    wrong_results = {}
    
    for prefix in wrong_prefixes:
        print(f"\n--- 测试错误前缀: '{prefix}' ---")
        avg_time, std_dev, times = measure_response_time(prefix, num_samples=10)
        wrong_results[prefix] = (avg_time, std_dev)
        print(f"平均时间: {avg_time:.6f}s (±{std_dev:.6f}s)")
        if times:
            print(f"最小时间: {min(times):.6f}s, 最大时间: {max(times):.6f}s")
    
    # 分析结果
    print("\n=== 分析结果 ===")
    
    print("\n正确前缀时间排序:")
    sorted_correct = sorted(correct_results.items(), key=lambda x: x[1][0], reverse=True)
    for i, (prefix, (avg_time, std_dev)) in enumerate(sorted_correct, 1):
        prefix_display = "''" if prefix == "" else f"'{prefix}'"
        print(f"{i}. {prefix_display}: {avg_time:.6f}s (±{std_dev:.6f}s)")
    
    print("\n错误前缀时间排序:")
    sorted_wrong = sorted(wrong_results.items(), key=lambda x: x[1][0], reverse=True)
    for i, (prefix, (avg_time, std_dev)) in enumerate(sorted_wrong, 1):
        print(f"{i}. '{prefix}': {avg_time:.6f}s (±{std_dev:.6f}s)")
    
    # 判断是否适合时间侧信道攻击
    print("\n=== 时间侧信道攻击可行性分析 ===")
    
    if not sorted_correct or not sorted_wrong:
        print("❌ 数据不足，无法分析")
        return
    
    best_correct_time = sorted_correct[0][1][0]
    best_wrong_time = sorted_wrong[0][1][0]
    
    print(f"最佳正确前缀时间: {best_correct_time:.6f}s")
    print(f"最佳错误前缀时间: {best_wrong_time:.6f}s")
    print(f"时间差异: {abs(best_correct_time - best_wrong_time):.6f}s")
    
    # 检查是否有明显的递增趋势
    edge_times = []
    for prefix in ["", "E", "Ed", "Edg", "Edge", "EdgeC", "EdgeCT", "EdgeCTF", "EdgeCTF{"]:
        if prefix in correct_results:
            edge_times.append(correct_results[prefix][0])
    
    if len(edge_times) >= 3:
        print(f"\nEdgeCTF前缀时间趋势:")
        for i, (prefix, time_val) in enumerate(zip(["", "E", "Ed", "Edg", "Edge", "EdgeC", "EdgeCT", "EdgeCTF", "EdgeCTF{"], edge_times)):
            prefix_display = "''" if prefix == "" else f"'{prefix}'"
            print(f"  {prefix_display}: {time_val:.6f}s")
        
        # 简单的趋势分析
        increasing_count = 0
        for i in range(1, len(edge_times)):
            if edge_times[i] > edge_times[i-1]:
                increasing_count += 1
        
        trend_ratio = increasing_count / (len(edge_times) - 1)
        print(f"\n递增趋势比例: {trend_ratio:.2%}")
        
        if trend_ratio > 0.6:
            print("✅ 时间有递增趋势，可能适合时间侧信道攻击")
        elif abs(best_correct_time - best_wrong_time) > 0.001:
            print("⚠️  虽然没有明显递增趋势，但有时间差异，可能仍可尝试")
        else:
            print("❌ 时间差异很小，可能不适合时间侧信道攻击")
    
    return sorted_correct, sorted_wrong

if __name__ == "__main__":
    print("验证时间侧信道攻击可行性")
    print("=" * 50)
    
    test_prefix_timing()
    
    print("\n验证完成!")