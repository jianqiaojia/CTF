#!/usr/bin/env python3
import socket
import time
import sys

def connect_to_server(host, port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(10)
    s.connect((host, port))
    return s

def interactive_debug():
    host = "ghost-in-the-stack.chall.edgesecurity.team"
    port = 1344
    
    print("[+] 连接到服务器进行交互式调试...")
    
    s = connect_to_server(host, port)
    
    print("[+] 接收初始菜单...")
    initial_data = s.recv(1024).decode(errors='ignore')
    print(f"收到: {initial_data}")
    
    while True:
        try:
            user_input = input("输入命令 (或 'quit' 退出): ")
            if user_input.lower() == 'quit':
                break
                
            s.send((user_input + "\n").encode())
            time.sleep(0.5)
            
            response = s.recv(4096).decode(errors='ignore')
            print(f"响应: {response}")
            
        except Exception as e:
            print(f"错误: {e}")
            break
    
    s.close()

def test_specific_scenario():
    """测试特定场景"""
    host = "ghost-in-the-stack.chall.edgesecurity.team"
    port = 1344
    
    print("[+] 测试特定攻击场景...")
    
    for test_id in range(10):
        print(f"\n[*] 测试 #{test_id + 1}")
        
        try:
            s = connect_to_server(host, port)
            
            # 接收菜单
            initial = s.recv(1024).decode(errors='ignore')
            print(f"菜单: {initial}")
            
            # 选择选项2
            s.send(b"2\n")
            time.sleep(0.2)
            
            # 接收premium access level提示
            resp1 = s.recv(1024).decode(errors='ignore')
            print(f"Premium提示: {resp1}")
            
            # 发送一个特定的数字
            test_number = test_id  # 尝试不同的数字
            s.send(f"{test_number}\n".encode())
            time.sleep(0.2)
            
            # 接收token提示
            resp2 = s.recv(1024).decode(errors='ignore')
            print(f"Token提示: {resp2}")
            
            # 发送空回车
            s.send(b"\n")
            time.sleep(0.5)
            
            # 接收最终响应
            final_resp = s.recv(4096).decode(errors='ignore')
            print(f"最终响应: {final_resp}")
            
            # 检查是否有有趣的输出
            if "Developer Mode Key" in final_resp or "0x" in final_resp:
                print("[SUCCESS] 发现可能的密钥泄露!")
                
            # 尝试继续交互
            s.send(b"1\n")
            time.sleep(0.2)
            more_resp = s.recv(1024).decode(errors='ignore')
            print(f"额外响应: {more_resp}")
            
            s.close()
            time.sleep(1)  # 避免过于频繁的连接
            
        except Exception as e:
            print(f"测试 #{test_id + 1} 失败: {e}")

def test_different_inputs():
    """测试不同的输入模式"""
    host = "ghost-in-the-stack.chall.edgesecurity.team"
    port = 1344
    
    test_inputs = [
        "",      # 空输入
        "0",     # 零
        "1",     # 小数字
        "999",   # 较大数字
        "a",     # 无效输入
        "0x123", # 十六进制格式
    ]
    
    for inp in test_inputs:
        print(f"\n[*] 测试输入: '{inp}'")
        
        try:
            s = connect_to_server(host, port)
            
            # 快速导航到问题位置
            s.recv(1024)  # 菜单
            s.send(b"2\n")
            s.recv(1024)  # premium prompt
            s.send(b"1\n")
            s.recv(1024)  # token prompt
            
            # 发送测试输入
            if inp == "":
                s.send(b"\n")
            else:
                s.send(f"{inp}\n".encode())
            
            time.sleep(0.5)
            response = s.recv(4096).decode(errors='ignore')
            print(f"响应: {response}")
            
            s.close()
            
        except Exception as e:
            print(f"测试输入 '{inp}' 失败: {e}")

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "interactive":
        interactive_debug()
    elif len(sys.argv) > 1 and sys.argv[1] == "inputs":
        test_different_inputs()
    else:
        test_specific_scenario()